/* * * @(#)IsoFn.java 0.2 98/09/16 * * Copyright (c) 1998 Ginger Booth.  All Rights Reserved. * * @history: original * @author Ginger Booth * @version 0.2, September 1998 *  note there was a CourseWare 0.1 prototype of iso, but this version was *  written from scratch rather than porting that one. */ /** IsoFn is the base class meeting the needs of IsoPlot2D for a function  *  to be added to an isoclines tableau. Provides isoclines and trajectories  *  for a parameterization of a system of predator/prey equations.  */package eco.iso;import courseware.util.*;import courseware.plot.*;import java.lang.reflect.*;import java.util.*;abstract public class IsoFn {  private static double maxTime = 5;  private static double dt = .005;  private static int plotNth = 50;  private String name = "System";  double prodBirth = 2;  double prodK = 10000;  double prodMigr = 0.1;  double herbBirth = 0.2;  double herbK = 1000;  double herbMigr = 0.05;  double herbKill = 1;  double carnBirth = 0.02;  double carnMigr = 0.01;  double carnKill = 1;  static final int PHC_MAX = 9;  public IsoFn() {    setName("Producer/Herbivore/Carnivore");  }  public void setParameter(int i, double value) {    switch (i) {      case 0: prodBirth = value; break;      case 1: prodK = value; break;      case 2: prodMigr = value; break;      case 3: herbBirth = value; break;      case 4: herbK = value; break;      case 5: herbMigr = value; break;      case 6: herbKill = value; break;      case 7: carnBirth = value; break;      case 8: carnMigr = value; break;      case 9: carnKill = value; break;    }  }  public String getParameterLabel(int i) {    switch (i) {      case 0: return "Producer birth rate";      case 1: return "Producer carrying capacity";      case 2: return "Producer migration rate";      case 3: return "Herbivore birth rate";      case 4: return "Herbivore carrying capacity";      case 5: return "Herbivore migration rate";      case 6: return "Carnivore consume rate";      case 7: return "Carnivore birth rate";      case 8: return "Carnivore migration rate";      case 9: return "Carnivore consume rate";      default : return "<unknown parameter>";    }  }  public double getParameter(int i) {    switch (i) {      case 0: return prodBirth;      case 1: return prodK;      case 2: return prodMigr;      case 3: return herbBirth;      case 4: return herbK;      case 5: return herbMigr;      case 6: return herbKill;      case 7: return carnBirth;      case 8: return carnMigr;      case 9: return carnKill;      default : return 0;    }  }  public int getNumParameters() { return PHC_MAX+1; }  public static void setMaxTime(double t) {maxTime = t;}  public static double getMaxTime() {return maxTime;}  public static void setDt(double dit) {dt = dit;}  public static double getDt() {return dt;}  public static void setPlotNth(int nth) {plotNth = nth;}  public static int getPlotNth() {return plotNth;}  public static boolean hasIsoclines() {return false;}  public PlottableFn getIsocline(int stateVar) {    return null;  }  double min(double a, double b) {    if(a > b)      return b;    else      return a;  }  double max(double a, double b) {    if(a < b)      return b;    else      return a;  }//  public double dNdt(int stateVar, double lastState[], double t, double dt) {//  return 5;/*    double herb = lastState[1];    double carn = lastState[2];    double ans;    if (stateVar == 0) {      return super.dNdt(stateVar, lastState, t, dt);    } else if (stateVar == 1) {      ans = super.dNdt(stateVar, lastState, t, dt);      ans -= dt * (carnKillrate * herbi * carni);      return ans;    } else {      ans = carnKillrate * herbi * carni            - carnDeath * carni            - carnFight * carni * carni;      ans *= dt;      return ans;    }  }*/  double[][] getTrajectory(double[] stateInit) {    double maxTime = getMaxTime();    double dt = getDt();    double plotNth = getPlotNth();    double dlen = ((maxTime / dt) / plotNth) + 1;    double plotDt = dt * plotNth;    int len = Math.round(Math.round(dlen + .1));    double[][] answer = new double[4][len];    answer[0][0] = 0;    answer[1][0] = stateInit[0];    answer[2][0] = stateInit[1];    answer[3][0] = stateInit[2];    double t = 0;    double next0;//    double[] lastState = new double[] {stateInit[0], stateInit[1], stateInit[2]};    double carnivore1 = stateInit[2]/4, carnivore2 = stateInit[2]/4, carnivore3 = stateInit[2]/4, carnivore4 = stateInit[2]/4;    double herbivore1 = stateInit[1]/4, herbivore2 = stateInit[1]/4, herbivore3 = stateInit[1]/4, herbivore4 = stateInit[1]/4;    double producer1 = stateInit[0]/4, producer2 = stateInit[0]/4, producer3 = stateInit[0]/4, producer4 = stateInit[0]/4;    double pprodD1, pprodR1, pprodL2, pprodD2, pprodU3, pprodR3, pprodL4, pprodU4;    double pherbD1, pherbR1, pherbL2, pherbD2, pherbU3, pherbR3, pherbL4, pherbU4;    double pcarnD1, pcarnR1, pcarnL2, pcarnD2, pcarnU3, pcarnR3, pcarnL4, pcarnU4;    double prodD1, prodR1, prodL2, prodD2, prodU3, prodR3, prodL4, prodU4;    double herbD1, herbR1, herbL2, herbD2, herbU3, herbR3, herbL4, herbU4;    double carnD1, carnR1, carnL2, carnD2, carnU3, carnR3, carnL4, carnU4;    // so calculate 'em....    for (int plottable = 1; plottable < len; plottable++) {      for (int dit=0; dit < plotNth; dit++) {        pprodD1 = Math.random();        pprodR1 = Math.random();      	pprodL2 = Math.random();      	pprodD2 = Math.random();      	pprodU3 = Math.random();      	pprodR3 = Math.random();      	pprodL4 = Math.random();      	pprodU4 = Math.random();      	pherbD1 = Math.random();      	pherbR1 = Math.random();      	pherbL2 = Math.random();      	pherbD2 = Math.random();      	pherbU3 = Math.random();      	pherbR3 = Math.random();      	pherbL4 = Math.random();      	pherbU4 = Math.random();      	pcarnD1 = Math.random();      	pcarnR1 = Math.random();      	pcarnL2 = Math.random();      	pcarnD2 = Math.random();      	pcarnU3 = Math.random();      	pcarnR3 = Math.random();      	pcarnL4 = Math.random();      	pcarnU4 = Math.random();        prodD1 = prodMigr*(producer1 - min(producer1,max(0,herbKill*herbivore1))/herbKill)*pprodD1/(pprodD1 + pprodR1);        prodR1 = prodMigr*(producer1 - min(producer1,max(0,herbKill*herbivore1))/herbKill)*pprodR1/(pprodD1 + pprodR1);      	prodL2 = prodMigr*(producer2 - min(producer2,max(0,herbKill*herbivore2))/herbKill)*pprodL2/(pprodD2 + pprodL2);      	prodD2 = prodMigr*(producer2 - min(producer2,max(0,herbKill*herbivore2))/herbKill)*pprodD2/(pprodD2 + pprodL2);      	prodU3 = prodMigr*(producer3 - min(producer3,max(0,herbKill*herbivore3))/herbKill)*pprodU3/(pprodU3 + pprodR3);      	prodR3 = prodMigr*(producer3 - min(producer3,max(0,herbKill*herbivore3))/herbKill)*pprodR3/(pprodU3 + pprodR3);      	prodL4 = prodMigr*(producer4 - min(producer4,max(0,herbKill*herbivore4))/herbKill)*pprodL4/(pprodL4 + pprodU4);      	prodU4 = prodMigr*(producer4 - min(producer4,max(0,herbKill*herbivore4))/herbKill)*pprodU4/(pprodL4 + pprodU4);      	herbD1 = herbMigr*(herbivore1 - min(herbivore1,max(0,herbKill*carnivore1))/herbKill)*pherbD1/(pherbD1 + pherbR1);      	herbR1 = herbMigr*(herbivore1 - min(herbivore1,max(0,herbKill*carnivore1))/herbKill)*pherbR1/(pherbD1 + pherbR1);      	herbL2 = herbMigr*(herbivore2 - min(herbivore2,max(0,herbKill*carnivore2))/herbKill)*pherbL2/(pherbL2 + pherbD2);      	herbD2 = herbMigr*(herbivore2 - min(herbivore2,max(0,herbKill*carnivore2))/herbKill)*pherbD2/(pherbL2 + pherbD2);      	herbU3 = herbMigr*(herbivore3 - min(herbivore3,max(0,herbKill*carnivore3))/herbKill)*pherbU3/(pherbU3 + pherbR3);      	herbR3 = herbMigr*(herbivore3 - min(herbivore3,max(0,herbKill*carnivore3))/herbKill)*pherbR3/(pherbU3 + pherbR3);      	herbL4 = herbMigr*(herbivore4 - min(herbivore4,max(0,herbKill*carnivore4))/herbKill)*pherbL4/(pherbL4 + pherbU4);      	herbU4 = herbMigr*(herbivore4 - min(herbivore4,max(0,herbKill*carnivore4))/herbKill)*pherbU4/(pherbL4 + pherbU4);      	carnD1 = min(min(carnivore1,max(0,carnKill*carnivore1))/carnKill, carnMigr*(carnivore1-min(carnivore1,max(0,carnKill*carnivore1))/carnKill))*pcarnD1/(pcarnD1 + pcarnR1);      	carnR1 = min(min(carnivore1,max(0,carnKill*carnivore1))/carnKill, carnMigr*(carnivore1-min(carnivore1,max(0,carnKill*carnivore1))/carnKill))*pcarnR1/(pcarnD1 + pcarnR1);      	carnL2 = min(min(carnivore2,max(0,carnKill*carnivore2))/carnKill, carnMigr*(carnivore2-min(carnivore2,max(0,carnKill*carnivore2))/carnKill))*pcarnL2/(pcarnL2 + pcarnD2);      	carnD2 = min(min(carnivore2,max(0,carnKill*carnivore2))/carnKill, carnMigr*(carnivore2-min(carnivore2,max(0,carnKill*carnivore2))/carnKill))*pcarnD2/(pcarnL2 + pcarnD2);      	carnU3 = min(min(carnivore3,max(0,carnKill*carnivore3))/carnKill, carnMigr*(carnivore3-min(carnivore3,max(0,carnKill*carnivore3))/carnKill))*pcarnU3/(pcarnU3 + pcarnR3);      	carnR3 = min(min(carnivore3,max(0,carnKill*carnivore3))/carnKill, carnMigr*(carnivore3-min(carnivore3,max(0,carnKill*carnivore3))/carnKill))*pcarnR3/(pcarnU3 + pcarnR3);      	carnL4 = min(min(carnivore4,max(0,carnKill*carnivore4))/carnKill, carnMigr*(carnivore4-min(carnivore4,max(0,carnKill*carnivore4))/carnKill))*pcarnL4/(pcarnL4 + pcarnU4);      	carnU4 = min(min(carnivore4,max(0,carnKill*carnivore4))/carnKill, carnMigr*(carnivore4-min(carnivore4,max(0,carnKill*carnivore4))/carnKill))*pcarnU4/(pcarnL4 + pcarnU4);        carnivore1 += dt*(carnBirth*(min(herbivore1,max(0,carnKill*carnivore1))/carnKill) + carnL2 + carnU3 - min(min(carnivore1,max(0,carnKill*carnivore1))/carnKill, carnMigr*(carnivore1-min(carnivore1,max(0,carnKill*carnivore1))/carnKill)) - carnivore1 + min(herbivore1,max(0,carnKill*carnivore1))/carnKill);        carnivore2 += dt*(carnBirth*(min(herbivore2,max(0,carnKill*carnivore2))/carnKill) + carnR1 + carnU4 - min(min(carnivore2,max(0,carnKill*carnivore2))/carnKill, carnMigr*(carnivore2-min(carnivore2,max(0,carnKill*carnivore2))/carnKill)) - carnivore2 + min(herbivore2,max(0,carnKill*carnivore2))/carnKill);      	carnivore3 += dt*(carnBirth*(min(herbivore3,max(0,carnKill*carnivore3))/carnKill) + carnD1 + carnL4 - min(min(carnivore3,max(0,carnKill*carnivore3))/carnKill, carnMigr*(carnivore3-min(carnivore3,max(0,carnKill*carnivore3))/carnKill)) - carnivore3 + min(herbivore3,max(0,carnKill*carnivore3))/carnKill);      	carnivore4 += dt*(carnBirth*(min(herbivore4,max(0,carnKill*carnivore4))/carnKill) + carnD2 + carnR3 - min(min(carnivore4,max(0,carnKill*carnivore4))/carnKill, carnMigr*(carnivore4-min(carnivore4,max(0,carnKill*carnivore4))/carnKill)) - carnivore4 + min(herbivore4,max(0,carnKill*carnivore4))/carnKill);      	herbivore1 += dt*((1 - herbivore1/herbK)*herbBirth*(min(producer1,max(0,herbKill*herbivore1))/herbKill) + herbL2 + herbU3 - min(min(herbivore1,max(0,herbKill*herbivore1))/herbKill, herbMigr*(herbivore1-min(herbivore1,max(0,herbKill*herbivore1))/herbKill)) - herbivore1 + min(producer1,max(0,herbKill*herbivore1))/herbKill);      	herbivore2 += dt*((1 - herbivore2/herbK)*herbBirth*(min(producer2,max(0,herbKill*herbivore2))/herbKill) + herbR1 + herbU4 - min(min(herbivore2,max(0,herbKill*herbivore2))/herbKill, herbMigr*(herbivore2-min(herbivore2,max(0,herbKill*herbivore2))/herbKill)) - herbivore2 + min(producer2,max(0,herbKill*herbivore2))/herbKill);      	herbivore3 += dt*((1 - herbivore3/herbK)*herbBirth*(min(producer3,max(0,herbKill*herbivore3))/herbKill) + herbD1 + herbL4 - min(min(herbivore3,max(0,herbKill*herbivore3))/herbKill, herbMigr*(herbivore3-min(herbivore3,max(0,herbKill*herbivore3))/herbKill)) - herbivore3 + min(producer3,max(0,herbKill*herbivore3))/herbKill);      	herbivore4 += dt*((1 - herbivore4/herbK)*herbBirth*(min(producer4,max(0,herbKill*herbivore4))/herbKill) + herbD2 + herbR3 - min(min(herbivore4,max(0,herbKill*herbivore4))/herbKill, herbMigr*(herbivore4-min(herbivore4,max(0,herbKill*herbivore4))/herbKill)) - herbivore4 + min(producer4,max(0,herbKill*herbivore4))/herbKill);      	producer1 += dt*((producer1 - min(producer1 ,max(0,herbKill*herbivore1))/herbKill)*prodBirth*(1 - producer1/prodK) + prodL2 + prodU3 - min(producer1,max(0,herbKill*herbivore1))/herbKill - prodMigr*(producer1-min(producer1,max(0,herbKill*herbivore1))/herbKill));      	producer2 += dt*((producer2 - min(producer2 ,max(0,herbKill*herbivore2))/herbKill)*prodBirth*(1 - producer2/prodK) + prodR1 + prodU4 - min(producer2,max(0,herbKill*herbivore2))/herbKill - prodMigr*(producer2-min(producer2,max(0,herbKill*herbivore2))/herbKill));      	producer3 += dt*((producer3 - min(producer3 ,max(0,herbKill*herbivore3))/herbKill)*prodBirth*(1 - producer3/prodK) + prodD1 + prodL4 - min(producer3,max(0,herbKill*herbivore3))/herbKill - prodMigr*(producer3-min(producer3,max(0,herbKill*herbivore3))/herbKill));      	producer4 += dt*((producer4 - min(producer4 ,max(0,herbKill*herbivore4))/herbKill)*prodBirth*(1 - producer4/prodK) + prodD2 + prodR3 - min(producer4,max(0,herbKill*herbivore4))/herbKill - prodMigr*(producer4-min(producer4,max(0,herbKill*herbivore4))/herbKill));        t += dt;      }      answer[0][plottable] = t;      answer[1][plottable] = producer1 + producer2 + producer3 + producer4;      answer[2][plottable] = herbivore1 + herbivore2 + herbivore3 + herbivore4;      answer[3][plottable] = carnivore1 + carnivore2 + carnivore3 + carnivore4;    }    return answer;  }  /** for 2-d system (predator/prey) returns array of 3 arrays:   *  time, predator, and prey. Calculates this anew each time.   *//*  double[][] getTrajectory(double[] stateInit) {    double dlen = ((maxTime / dt) / plotNth) + 1;    double plotDt = dt * plotNth;    int len = Math.round(Math.round(dlen + .1));    double[][] answer = new double[3][len];    answer[0][0] = 0;    answer[1][0] = stateInit[0];    answer[2][0] = stateInit[1];    double t = 0;    double next0;    double[] lastState = new double[] {stateInit[0], stateInit[1]};    // so calculate 'em....    for (int plottable = 1; plottable < len; plottable++) {      for (int dit=0; dit < plotNth; dit++) {        next0 = lastState[0] + dNdt(0, lastState, t, dt);        lastState[1] += dNdt(1, lastState, t, dt);        lastState[0] = next0;        t += dt;      }      answer[0][plottable] = t;      answer[1][plottable] = lastState[0];      answer[2][plottable] = lastState[1];    }    return answer;  }  */  public ParamList getSystemParameters() {    ParamList answer = new ParamList(getName() + " Parameters");    Class[] signature = new Class[]            { int.class, double.class };    Method setMethod;    IndexParam param;    try {      setMethod = this.getClass().getMethod("setParameter", signature);    } catch (Exception e) {      System.err.println("Error " + e);      System.err.println("Can't find method setParameter");      return null;    }    int num = getNumParameters();    for (int i=0; i<num; i++) {      Integer I = new Integer(i);      Double D = new Double(getParameter(i));      Object[] value = new Object[] { I, D };      param = new IndexParam(getParameterLabel(i), value, this,          setMethod, true);      answer.add(param);    }    return answer;  }  /** Set all parameters via one string. */  public void setArgs(String allArgs) {      StringTokenizer chopper = new StringTokenizer(allArgs);      int tokenCount = chopper.countTokens();      int last = getNumParameters();      if (last != tokenCount)        System.err.println("Warning: in IsoFn.setArgs: wrong number of parameters in string!");      if (tokenCount < last)        last = tokenCount;      Double d;      for (int i=0; i<last; i++) {          d = new Double(chopper.nextToken());          setParameter(i, d.doubleValue());      }  }//  public void setParameter(int i, double value) {}//  public String getParameterLabel(int i) {return "Arg#" + i;}//  public double getParameter(int i) {return 0;}//  public int getNumParameters() { return 0; }//  abstract public double dNdt(int stateVar, double lastState[], double t, double dt);//  abstract public PlottableFn getIsocline(int stateVar);  public String getName() { return name;}  public void setName(String s) { name = s;}}