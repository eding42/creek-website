/* * * @(#)MouseTrajectory.java 0.2 98/11/20 * * Copyright (c) 1998 Ginger Booth.  All Rights Reserved. * * @history: original, based on SlopeHandler * @author Ginger Booth * @version 0.2, 98/11 */package eco.iso;import java.awt.event.*;import courseware.util.*;import courseware.plot.*;import java.awt.*;import java.text.NumberFormat;/**  MouseTrajectory makes a button for adding trajectories to an isocline *   system by mouse click. This button is not placed on the user *  interface--caller needs to call MouseTrajectory.getButton() and *  place the button wherever. The button is built, though, with *  listeners all ready to do the mouse-traj-thing if the button *  is pressed. Part of the mouse-traj-thing is turning off the *  plot-zoom-thing temporarily, so when the mouseTraj button is *  pressed, the mouse is reset to do the mouseTraj thing and the *  button is reset to restore the zoom thing. Thus the button is *  a switch. */public class MouseTrajectory{    PlotFn plotFn;            // can reset which Plot this talks to.    private MatchedButton button;    // this class re-assigns what this button does    private CourseWareApplet commentMgr;    private Isoclines isoclines; // call back with addTrajectory    private boolean trajing;  // mode flag, sloping or quiescent    private String trajLabel  = "Mouse Trajectory";    private String zoomLabel  = "Zoom";    private MouseAdapter trajUp;    private ActionListener trajStartListener;    private ActionListener zoomResumeListener;    /** Use getButton() to get the button this makes.*/    public MouseTrajectory(PlotFn aPlot, CourseWareApplet comments, Isoclines owner) {        plotFn     = aPlot;        commentMgr = comments;        isoclines  = owner;        button = new MatchedButton(trajLabel);        // make my listeners for button        trajStartListener = new ActionListener() {            public void actionPerformed(ActionEvent e) {                trajStart();            }        } ;        zoomResumeListener = new ActionListener() {            public void actionPerformed(ActionEvent e) {                zoomResume();            }        } ;        // now for the mouse listeners...most do nothing, but plotFn does        // something, so have to replace that with some nothing? Try just        // adding the one that's useful for now....        trajUp = new MouseAdapter() {            public void mouseReleased(MouseEvent e) {                doAddTrajectory (e.getX(),e.getY());            }        } ;        setTrajing(false);    }    /** Routine cannot consult trajing flag, only set it.*/    protected void setTrajing(boolean newstate) {        trajing  = newstate;        // don't know state, so remove all possible button listeners        try {            button.removeActionListener(zoomResumeListener);            button.removeActionListener(trajStartListener);        } catch (Exception e) { }        if (!trajing) {            plotFn.setZoom(true);            button.setVisible(false);            button.setLabel(trajLabel);            button.setVisible(true);            // button.getParent().repaint(); makes entire module invisible....            button.validate();            button.addActionListener(trajStartListener);            plotFn.removeMouseListener(trajUp);        } else {            plotFn.setZoom(false);            button.setVisible(false);            button.setLabel(zoomLabel);            button.setVisible(true);            button.validate();            button.addActionListener(zoomResumeListener);            plotFn.addMouseListener(trajUp);        }    }    /** Public because it has to be for a listener, not because caller     *  has any business calling it! */    public void zoomResume() {        setTrajing(false);        zoomSpiel();    }    /** Public because it has to be for a listener, not because caller     *  has any business calling it! */    public void trajStart() {        setTrajing(true);        trajSpiel();    }    protected void zoomSpiel() {        commentMgr.comment("* Mouse zooms plot.");    }    protected void trajSpiel() {        commentMgr.comment("* Click on phase plot to add new population trajectory.");        commentMgr.comment("* Click on button again to restore mouse to zoom.");    }    public MatchedButton getButton() { return button; }    /** Only needed if reusing same handler for multiple plots.*/    public void setPlot(PlotFn aPlot) {        plotFn     = aPlot;        setTrajing(false);    }    /** Override default button labels.*/    public void setLabels(String slabel, String zlabel) {        trajLabel = slabel;        zoomLabel  = zlabel;        if (trajing)            button.setLabel(zlabel);        else            button.setLabel(slabel);        button.repaint();    }    /** Note, there's not really any good answer for which "rounded" initial     *  population to use. The software isn't aware of what might look "round"     *  to the user. So, here, we'll take the closest integers.     */    public void doAddTrajectory (int eventx, int eventy) {      double wx = Math.rint(plotFn.x_value(eventx));      double wy = Math.rint(plotFn.y_value(eventy));      isoclines.addTrajectory("Init: " + wx +"," +wy, wx, wy);    }}