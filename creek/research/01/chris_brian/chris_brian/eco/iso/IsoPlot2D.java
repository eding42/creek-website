/* * * @(#)IsoPlot2D.java 0.2 98/09/16 * * Copyright (c) 1998 Ginger Booth.  All Rights Reserved. * * @history: original * @author Ginger Booth * @version 0.2, September 1998 *  note there was a CourseWare 0.1 prototype of iso, but this version was *  written from scratch rather than porting that one. * 981120, made the isocline traces themselves optional, for Os' pedagogical *  purposes (he wants to show phase plot without first, then with.) */ /** IsoPlot2D manages the paired phaseplot/timeseries plot. State Var 1  *  goes on the vertical axis, state var 0 on the horizontal.  */package eco.iso;import courseware.util.*;import courseware.plot.*;import java.awt.*;import java.lang.reflect.*;public class IsoPlot2D {  PlotFn phasePlot;  Plot timePlot;  IsoFn isoFn;  CourseWareAdapter panel; // the container we're in  int numStateVars = 2; // that's what the 2D in IsoPlot2D means....  String[] stateLabels = new String[] { "Prey", "Predator" };  String[] timeLabels  = new String[] { "Time", "Population" };  String scolor  = "Colors";  double[] stateMax = new double[] { 20.0, 20.0 };  double timeMax   = 20;  double[] stateInit = new double[] { 10, 10 };  private static int stateColor0 = 1;  private static int stateColor1 = 2;  private static int oldTrajectoryColor = 0;  private static int newTrajectoryColor = 3;  private int isoSteps = 101;  private String trajectoryName;  // vfb, 981120, added hook so can use same machinery with or without the  // isoclines displayed, for Os' pedagogical purposes.  private boolean showIsoclines = true;  public IsoPlot2D(CourseWareAdapter panel) {    this.panel = panel;    colorSetup();  }  public void setShowIsoclines(boolean b) {showIsoclines = b; }  public boolean getShowIsoclines() {return showIsoclines;}  /** Custom colorscheme.   *  0 = BLACK = state var 1   *  1 = White = state var 0   *  2 = Brown = old trajectory   *  3 = Green = latest trajectory   */  protected void colorSetup() {    Palette pal = new PaletteBBW();    pal.addColorHSB(Palette.bluebegin, 1.0f,                Palette.defbright, "new trajectory");    pal.getColorObj(0).name=stateLabels[1];    pal.getColorObj(1).name=stateLabels[0];    pal.getColorObj(2).name="old trajectory";    panel.makePaletteButton(scolor, 1);    panel.setPalette(pal);    panel.keepPalette();  }  protected double getStateMax() {    double max = stateMax[0];    for (int i=1; i < numStateVars; i++)      if (stateMax[i] > max)        max = stateMax[i];    return max;  }  public void finalize() {    if (phasePlot != null) {      phasePlot.setVisible(false);      phasePlot.clear();      phasePlot.finalize();    }    if (timePlot != null) {      timePlot.setVisible(false);      timePlot.clear();      timePlot.finalize();    }    try {      super.finalize();    } catch (Throwable t) {};  }  public void makePlots () {    // get rid of old plots    finalize();    MemCleaner.cleanup();    int dummysize = 200; // doesn't matter--it takes what's left    Dimension plotsize = new Dimension(dummysize, dummysize);    boolean wantlegend = true;    phasePlot = new PlotFn(plotsize,        stateLabels[0], stateLabels[1], 0, 0, stateMax[0], stateMax[1],        wantlegend, panel.cwaOwner());    timePlot = new Plot(plotsize,        timeLabels[0], timeLabels[1], 0, 0, timeMax, getStateMax(), wantlegend,        panel.cwaOwner());    ModuleLayout lm = (ModuleLayout) panel.getLayout();    panel.add(phasePlot, ModuleLayout.BIG_STRING);    panel.add(timePlot, ModuleLayout.BIG_STRING);    lm.setConstraint(phasePlot, 0, ModuleLayout.BIG);    lm.setConstraint(timePlot, 1, ModuleLayout.BIG);    phasePlot.setVisible(true);    timePlot.setVisible(true);    isoFn = null;  }  /** does nothing but remember this fact. */  public void setFunction(IsoFn iso) {isoFn = iso;}  public IsoFn getFunction() { return isoFn;}  public void setStateLabel(int which, String what) {    stateLabels[which] = what;    if (phasePlot != null) {      if (which == 1)        phasePlot.setYAxisLabel(what);      else        phasePlot.setXAxisLabel(what);    }    if (which==1)      panel.getPalette().getColorObj(0).name=stateLabels[1];    else      panel.getPalette().getColorObj(1).name=stateLabels[0];  }    public void setTimeLabel(int which, String what) {    timeLabels[which] = what;    if (timePlot != null) {      if (which == 1)        timePlot.setYAxisLabel(what);      else        timePlot.setXAxisLabel(what);    }  }  public void clearTrajectories() {    if (phasePlot == null) return;    int numNow = phasePlot.getNumTraces();    int shouldBe = showIsoclines ? 2 : 0;    if (numNow > shouldBe)      phasePlot.removeTraces(shouldBe, numNow-1);    timePlot.clear();    panel.repaint();  }  /** Workhorse 2 of this class. Add the isoclines, only if the plot is empty.   */  public void addIsoclines() {    if (phasePlot == null)      return;    if (!showIsoclines)      return;    if (!isoFn.hasIsoclines()) {      showIsoclines = false;      return;    }    if (phasePlot.getNumTraces() > 0)      return;          PlottableFn iso0 = isoFn.getIsocline(0);    PlottableFn iso1 = isoFn.getIsocline(1);    phasePlot.addTrace(panel.getPalette().getColor(stateColor1),      iso1.getName(), iso1, isoSteps);    phasePlot.addTrace(panel.getPalette().getColor(stateColor0),      iso0.getName(), iso0, isoSteps);  }  double maxOf(double[] d) {    double max = d[0];    for (int i=1; i< d.length; i++)      if (d[i] > max)        max = d[i];    return max;  }  /** regenerate all traces after change in parameters of system */  public void rerun() {    // not ready for reruns....    if (isoFn == null)      return;    phasePlot.clear();    timePlot.clear();    addIsoclines();    addTrajectory(trajectoryName, stateInit[0], stateInit[1]);    panel.repaint();  }  public Param getTrajectoryParameters() {    String suggestedName = stateInit[0]+","+stateInit[1];    Class[] signature = new Class[]            { String.class, double.class, double.class };    Method addMethod;    try {      addMethod = this.getClass().getMethod("addTrajectory", signature);    } catch (Exception e) {      System.err.println("can't find method IsoPlot2D.addTrajectory");      return null;    }    Object[] val = new Object[]        {suggestedName,         new Double(stateInit[0]),         new Double(stateInit[1]) };    UnlabeledArgListParam answer =      new UnlabeledArgListParam("Add Trajectory", val, 3);    answer.method=addMethod;    answer.owner=this;    answer.setArgLabels("/Plot label/Init " + stateLabels[0] +      "/Init " + stateLabels[1] + "/");    return (Param) answer;  }  /** Workhorse 1 of this class. Adds the isoclines if they haven't   *  already been added.   */  public void addTrajectory(String label, double state0, double state1) {    stateInit[0] = state0;    stateInit[1] = state1;    trajectoryName = label;    if (phasePlot == null)      return;    if ((phasePlot.getNumTraces() < 2) && (showIsoclines) ) {      phasePlot.clear();      addIsoclines();    }    if (isoFn == null)      return;    // calculate the trajectory & add to phase plot    double[] stateInit = new double[] { state0, state1 };    double[][] threeD = isoFn.getTrajectory(stateInit);    phasePlot.addTrace(panel.getPalette().getColor(newTrajectoryColor), label,      threeD[1], threeD[2]);    // phase plot bookkeeping    int traces = phasePlot.getNumTraces();    int firstTraj = showIsoclines ? 2 : 0;    if (traces > firstTraj+1) {      for (int i=firstTraj; i<traces - 1; i++) {        DataTrace dt = phasePlot.getTrace(i);        dt.setColor(panel.getPalette().getColor(oldTrajectoryColor));      }      double max = maxOf(threeD[1]);      if (max > stateMax[0])        stateMax[0] = max;      max = maxOf(threeD[2]);      if (max > stateMax[1])        stateMax[1] = max;    } else {      stateMax[0] = maxOf(threeD[1]);      stateMax[1] = maxOf(threeD[2]);    }    phasePlot.resetRange(0,0,stateMax[0], stateMax[1]);    phasePlot.setNeedRepaint(true);    // add to time plot & bookkeeping    timePlot.clear();    timePlot.addTrace(panel.getPalette().getColor(stateColor1), stateLabels[1],      threeD[0], threeD[2]);    timePlot.addTrace(panel.getPalette().getColor(stateColor0), stateLabels[0],      threeD[0], threeD[1]);    double maxState = maxOf(stateMax);    timePlot.resetRange(0, 0, isoFn.getMaxTime(), maxState);    timePlot.setNeedRepaint(true);    panel.repaint();  }  public void setIsoSteps(int n) {isoSteps = n;}  public int getIsoSteps() { return isoSteps;}}