/* * * @(#)PlotFn.java 0.2 980515 * * Copyright (c) 1997 Ginger Booth.  All Rights Reserved. * * @history: original from: * @author Ginger Booth * @version 0.1, August 1997 */package courseware.plot;import java.applet.*;import java.awt.*;import java.util.*;/** This is a basic plot which calls PlottableFn's to generate data. */public class PlotFn extends Plot {    private Vector others = new Vector(0,1);    public PlotFn(Dimension size, String x_l, String y_l,                double xMin, double yMin, double xMax, double yMax,                boolean legend, Applet owner) {        super(size, x_l, y_l, xMin, yMin, xMax, yMax, legend, owner);    }    public PlotFn() {        super();    }    /** This only exists as a broker for the other two. */    public void addTrace(Color c, String label, FnParam function,                         int steps)    {      if (function.isGenerable()){        addTrace(c, label, (GenerableFn)function, steps);      } else {        addTrace(c, label, (FnOfX)function, steps);      }    }    /** This only exists as a broker for the other two. */    public void addTrace(Color c, String label, PlottableFn function,                         int steps)    {      if (function instanceof FnParam){        addTrace(c, label, (FnParam)function, steps);      } else if (function instanceof FnOfX) {        addTrace(c, label, (FnOfX)function, steps);      } else if (function instanceof GenerableFn) {        addTrace(c, label, (GenerableFn)function, steps);      }    }    /** Note it's all over when you add the trace--this calls the function     *  to generate the whole trace's data.     *  ALSO NOTE: there's nothing preventing you from adding ordinary     *  DataTrace's to a PlotFn. Just use Plot's addTrace methods. The     *  usual limitations to DataTraces apply--no extension as zoom out.     */    public void addTrace(Color c, String label, FnOfX function,                         int steps)    {        FnTrace t = new FnTrace(function, c, steps);        t.setLabel(label);        data.insertElementAt(t, numTraces);        numTraces++;        double stepX = (xmax - xmin) / (steps - 1);        double x = xmin;        // Just in case there's a cache involved, call with max then min.        function.fOfX(xmax, stepX);        double adjx = x;        double effectivemax = xmax + stepX*.5;        while (x <= effectivemax) {            adjx = function.xOfX(x, stepX);            t.add(adjx, function.fOfX(x, stepX));            x += stepX;        }        setNeedRepaint(true);    }    /** Note it's all over when you add the trace--this calls the function     *  to generate the whole trace's data.     */    public void addTrace(Color c, String label, GenerableFn function,                         int steps)    {        FnTrace t = new FnTrace(function, c, steps);        t.setLabel(label);        double[][] ptlist = function.getPoints(steps, xmin, ymin, xmax, ymax);        t.setX(ptlist[0]);        t.setY(ptlist[1]);        t.setSteps(steps);        data.insertElementAt(t, numTraces);        numTraces++;        setNeedRepaint(true);    }    public void addOther(PlottableOther other) {      others.addElement(other);      setNeedRepaint(true);    }    public void paint (Graphics g) {      super.paint(g);      for (int i=0; i<others.size(); i++) {        PlottableOther po = (PlottableOther) others.elementAt(i);        po.plotData(this);      }    }    public void clear() {      super.clear();      others = new Vector(0,1);    }    /** getNumTraces says how many are here. No guarantee that they're all     *  PlottableFn's, though.... */    public PlottableFn getFn(int i) {        if (i >= data.size())          return null;        Object maybeFn = data.elementAt(i);        if (maybeFn instanceof FnTrace) {          FnTrace t = (FnTrace) data.elementAt(i);          return t.getFn();        }        return null;    }    /** The step size is specific to which function.... */    public double getStepX(int i) {        if (i>=data.size())          return 0;        Object t = data.elementAt(i);        if (t instanceof FnTrace)          return (xmax - xmin) / ( ((FnTrace)t).getSteps() - 1 );        else if (t instanceof GenerableFn)          return ((FnTrace)t).getSteps();        else          return 0;    }    /** Overrides super to regenerate all traces. */    protected void scale()    {        super.scale();        regenTraces();    }    /** regenerate each trace's points list, iff FnTrace */    public void regenTraces() {      for (int i=0; i<data.size(); i++) {        if (!(data.elementAt(i) instanceof FnTrace))          continue;        FnTrace d = (FnTrace) data.elementAt(i);        if ( ((d.getFn() instanceof FnParam) && ( ((FnParam)d.getFn()).isGenerable()) ||             ( !(d.getFn() instanceof FnParam)) && (d.getFn() instanceof GenerableFn)) ){          GenerableFn f = (GenerableFn) d.getFn();          double[][] ptsList =            f.getPoints(d.getSteps(), xmin, ymin, xmax, ymax);          d.setX(ptsList[0]);          d.setY(ptsList[1]);        } else {          d.clear();          d.setLabel(d.getFn().getName());          d.allocate(d.getSteps());          double stepX = (xmax - xmin) / (d.getSteps() - 1);          double x = xmin;          // Just in case there's a cache involved, call with max then min.          FnOfX f = (FnOfX) d.getFn();          f.fOfX(xmax, stepX);          double effectivemax = xmax + stepX*.5;          while (x <= effectivemax) {              double adjx = f.xOfX(x, stepX);              d.add(adjx, f.fOfX(x, stepX));              x += stepX;          }        }      }      setNeedRepaint(true);    }    public void removeTrace(String l)    {        DataTrace d;        look:        for (int i=0; i<data.size(); i++) {            d = (FnTrace) data.elementAt(i);            if (l.equals(d.getLabel())) {                data.removeElementAt(i);                numTraces--;                break look;            }        }        setNeedRepaint(true);    }    public void removeAll() {      clear();      others = new Vector(0,1);      setNeedRepaint(true);    }       }