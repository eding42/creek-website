/* *  * @(#)CompositeFnParam.java 0.2 980723 * * Copyright (c) 1998 Ginger Booth.  All Rights Reserved. *  * @history: original * @author Ginger Booth * @version 0.1, October 1997 * @version 0.2, July, 1998 */package courseware.plot;import java.awt.*;import java.util.*;import courseware.util.*;/** A Composite function is one built out of other functions-- *  typically a "kitchen sink" type function. The default composite *  value at fOfX(double,double) is the sum of all member functions' *  values at fOfX(double,double), but you can override method *  composite(double[]) to do products, exponents, or whatever. * *  What goes on the popup is determined by the member functions. */public class CompositeFnParam extends FnParam        implements FnOfX, Cloneable {    public CompositeFnParam(String name, Object[] val)    {        super(name, val, val.length);        displayable = true;    }    public CompositeFnParam() {        super();        displayable = true;    }    /** Calls apply() on each member function. */    public void apply() {        FnParam fnParam;        for (int i=0; i< value.length;i++) {            fnParam = (FnParam) value[i];            fnParam.apply();        }    }    /** Calls setDepVar(name) on each member function. */    public void setDepVar(String depVarName) {        FnParam fnParam;        for (int i=0; i< value.length;i++) {            fnParam = (FnParam) value[i];            fnParam.setDepVar(depVarName);        }    }    /** Calls setIndepVar(name) on each member function. */    public void setIndepVar(String indepVarName) {        FnParam fnParam;        for (int i=0; i< value.length;i++) {            fnParam = (FnParam) value[i];            fnParam.setIndepVar(indepVarName);        }    }    /** Calls fOfX on each member, calls composite to figure     *  out what the composite value of all that is.     */    public double fOfX(double x, double stepx) {        double[] subval = new double[value.length];        FnParam subfn;        for (int i=0; i<value.length; i++) {            subfn = (FnParam) value[i];            subval[i] = subfn.fOfX(x, stepx);        }        return composite(subval);    }    public double composite(double[] subval) {        double answer = 0;        for (int i=0; i<subval.length;i++)            answer+= subval[i];        return answer;    }    /** This is the ONLY method of setArgs which should be called by     *  the parameter file. One string which implicitly says how     *  many functions there are. The delimiter between arguments is a     *  blank. All arguments are interpreted as FnParam's.     */    public void setArgs(String allArgs) {        if (allArgs == null) {            value       = null;            numberValue = null;            setNumVisible(0);            return;        }        StringTokenizer chopper = new StringTokenizer(allArgs);        int tokenCount = chopper.countTokens();        if (getNumVisible() == 0)            setNumVisible(tokenCount);        value = new Object[tokenCount];        FnParam fnParam;        String fnString;        int target = 0;        for (int i=0; i<tokenCount; i++) {            fnString = chopper.nextToken();            try {                fnParam = (FnParam)                           Class.forName(fnString).newInstance();                value[target] = fnParam;            } catch (Exception e) {                System.err.println("Error building composite:" + e.toString());                System.err.println("   attempting to add " + fnString +                                   " to CompositeFnParam " + getName());                target--;            }            target++;         }         if (target < value.length - 1) {            Object[] truncvalue = new Object[target];            for (int j=0; j<target; j++)                truncvalue[j] = value[j];            value = truncvalue;         }    }    /** The is a purposeful no-op. */    public void setArgs(Object[] val) { }    /** Override components() to set one line. Override addToPopup     *  for a multiline parameter. This is akin to a ParamList.     */    public void addToPopup(Container target, int startcolumn) {        TableLayout tl = (TableLayout) target.getLayout();        int myColumn = startcolumn;        if (!displayable)            return;        FnParam fnParam;        for (int i=0; i<value.length; i++) {            fnParam = (FnParam) value[i];            fnParam.addToPopup(target, startcolumn);        }    }    /** What to do after popup pops down. */    public void popDown(Container target) {        TableLayout table = (TableLayout) target.getLayout();        int row = myRow;        Vector cList;        FnParam fnParam;        for (int i=0; i<value.length; i++) {            fnParam = (FnParam) value[i];            if (fnParam.displayable) {                cList = table.getRow(fnParam.myRow);                fnParam.readComponents(cList, myColumn);                cList.removeAllElements();                apply();            }        }    }    public Object clone() {      CompositeFnParam newbie = new CompositeFnParam(name, value);      FnParam copysub;      for (int i=0; i<value.length; i++) {        copysub = (FnParam) value[i];        copysub = (FnParam) copysub.clone();        newbie.value[i] = copysub;      }      return newbie;    }}