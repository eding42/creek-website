/* *  * @(#)FnParam.java 0.2 980713 * * Copyright (c) 1998 Ginger Booth.  All Rights Reserved. *  * @history: original * @author Ginger Booth * @version 0.1, October 1997 * @version 0.2, July, 1998 */package courseware.plot;import java.awt.*;import java.util.*;import courseware.util.*;import java.lang.reflect.*;/** You can only use an FnParam if all arguments are doubles. If they *  are, no doubt you'll be happier to work with a double array for *  your arithmetic. * * By default, this is a FnOfX. If Generable wanted, set generable flag. * *  WARNING: there are a bunch of hooks in here to add color rgb *  editing fields, or a drop-down list of the palette to choose *  from, but I didn't finish this work. Though they'll probably *  show up, the machinery to get them APPLIED is missing. */public class FnParam extends ArgListParam implements FnOfX, GenerableFn {    private String indepVar = "x";    // string atoms    private String depVar = "f(x)";   // string atoms    protected double[] numberValue;   // double version of value[] array    private boolean generableFlag = false;  // true if a GenerableFn    /** The first nvisible values in the val[] array are to be     *  visible on the popup. All other args must be shuffled to     *  the end of the list.     *  If ColorObj != null, color added to popup menu. If Palette     *  null, no choice but to add color as editable rgb values.     *  If ParamList paletteList != null, color is an ExecButton that     *  spawns another ParamDialog for selecting/editing color.     *  Whether -that- popup is rgb's or selection and how the edits     *  there get applied to the function here, is the caller's     *  problem for now.     */    public FnParam(String name, Object[] val, int nvisible)    {        super(name, val, nvisible);        copyValueToNumbers();        displayable = true;    }    public FnParam() {        super();        displayable = true;    }    public String getName(){return name;}    /** Calls setArgs, then applies no-arg method, if any. */    public void apply() {        setArgs(value);        if ((method != null) && (owner != null)) {            try {                method.invoke(owner, Param.NO_ARGS);            } catch (IllegalAccessException e) {                System.err.println("Param.apply(): " + e + ", on " + this);            } catch (InvocationTargetException e) {                System.err.println("Param.apply(): target returned " +                e.getTargetException() + ", on " + this);            }        }    }    /** Nonsense default, so FnParam is not abstract.*/    public double fOfX(double x, double stepx) {return 0;}    /** Good default--xOfX is x. */    public double xOfX(double x, double stepx) {return x;}    /** Nonsense default, so GenerableFn is not abstract.*/    public double[][] getPoints(int suggestedNpts, double x0, double y0,		                            double x1, double y1)    {      double[][] answer = new double[2][2];      answer[0][0] = x0;      answer[0][1] = x1;      answer[1][0] = y0;      answer[1][1] = y1;      return answer;    }    public boolean isGenerable() { return generableFlag;}    public void setGenerable(boolean b) { generableFlag = b;}    public void setDepVar(String depVarName) { depVar = depVarName;}    public void setIndepVar(String indepVarName) { indepVar = indepVarName;}    public String getDepVar() {return depVar;}    public String getIndepVar() {return indepVar;}    public double[] getNumberValue() { return numberValue;}    public void setNumberValue(double[] newNumberValue) {      numberValue = newNumberValue;      if (getNumVisible() > numberValue.length) {        setNumVisible(numberValue.length);      }    }    public void copyValueToNumbers() {      if (value == null) return;      numberValue = new double[value.length];      for (int i=0; i<value.length; i++) {          if (value[i] instanceof Double)              numberValue[i] = ((Double)value[i]).doubleValue();      }    }    public void copyNumbersToValue() {      for (int i=0; i<numberValue.length; i++) {          value[i] = (Object) new Double(numberValue[i]);      }    }  /** The setArg routines are complicated by keeping second   *  copy of arguments around as double[] instead of Object[].   *  Can't perform arithmetic well on Object[]...   */  public void setArg(int which, Object val) {    value[which] = val;    numberValue[which] = ((Double)val).doubleValue();  }  public void setArg(int which, double val) {    value[which] = new Double(val);    numberValue[which] = val;  }    /** This is the method of setArgs which should be called by     *  the parameter file. One string which implicitly says how     *  many args there are. The delimiter between arguments is a     *  blank. All arguments are interpreted as doubles.     */    public void setArgs(String allArgs) {        if (allArgs == null) {            value       = null;            numberValue = null;            setNumVisible(0);            return;        }        StringTokenizer chopper = new StringTokenizer(allArgs);        int tokenCount = chopper.countTokens();        if (getNumVisible() == 0)            setNumVisible(tokenCount);        value = new Object[tokenCount];        numberValue = new double[tokenCount];        Double d;        for (int i=0; i<tokenCount; i++) {            d              = new Double(chopper.nextToken());            value[i]       = d;        }        copyValueToNumbers();    }    /** This version of setArgs is for the Parameter machinery, not the    *  parameter file.    */    public void setArgs(Object[] val) {        super.setArgs(val);        copyValueToNumbers();    }    public Object clone() {        Object newbie = super.clone();        FnParam newp = (FnParam) newbie;        newp.copyValueToNumbers();        return newbie;    }    public void setFrom(FnParam master) {        value = new Object[master.value.length];        numberValue = new double[master.value.length];        for (int i=0;i<value.length; i++) {            value[i] = master.value[i];            numberValue[i] = master.numberValue[i];        }        name = master.name;        owner = master.owner;        ownerClass = master.ownerClass;        method = master.method;        displayable = master.displayable;        depVar = master.depVar;        indepVar = master.indepVar;    }}