/* * * @(#)Plot.java 0.2 98/05/15 * * Copyright (c) 1997-1998 Ginger Booth.  All Rights Reserved. * * @history: original from: * @author Friedrich Schotte * @version 1.0, May 1997 (for Java 1.0) * @author Ginger Booth * @version 0.1, August 1997, overhaul (simplify & extend) */package courseware.plot;import java.lang.*;import java.io.*;import java.awt.*;import java.awt.event.*;import java.awt.image.*;import java.net.*;import java.text.*;import java.applet.*;import java.util.Vector;import java.util.StringTokenizer;import java.util.Enumeration;import courseware.util.*;/** * Include high resolution graphics in Web pages * * This applet is designed for the scientific needs rather than for business graphics. * It will display ten thousands of data points with error bars, but you will miss any * fancy graphics options as stacked bars in 3D look or pie charts. * * @author Friedrich Schotte * @version 1.0, May 1997 (for Java 1.0) * @author Ginger Booth * @version 0.1, August 1997 (for Java 1.0), gut. */public class Plot extends BufferCanvas{    private Rectangle area = new Rectangle();    protected double xmin = 0,xmax = .1,ymin = 0,ymax =.1;    protected double truexmin = 0,truexmax = 1,trueymin = 0,trueymax =1;    private Rectangle selection = new Rectangle();    private boolean paintBetweenXorFlag = false; // xor_selection/paint contention broker    private String error;    private int tick_spacing = 60, tick_length = 2;    private int tick_sigdigitsX = 4;    private int tick_sigdigitsY = 4;    private int maxYLabelLen = 7; // until set....    // used to format tick mark numbers    // Java is really annoying in this area--there is no hook to simply    // say, round the sucker into 5 spaces, etc.  So need to apply a    // number truncater, AND for internationalization, a number formatter.    private NumberFormat formatX = NumberFormat.getNumberInstance();    private NumberFormat formatY = NumberFormat.getNumberInstance();    protected Vector data = new Vector();	// DataTrace's    protected int numTraces  = 0;    private boolean includeLegend;    private boolean needRepaint = true;    private int ta = 30; // tick allocation    private Vector x_ticks = new Vector(ta, ta), y_ticks = new Vector(ta, ta);    private Vector x_ticksD = new Vector(ta, ta), y_ticksD = new Vector(ta, ta);    private Vector colors  = new Vector();    // Color.lightGray didn't work well on Mac's as a default, vfb, 000229    private Color gridColor = new Color(153, 153, 153);    private String x_axis_label,y_axis_label;    private Font normalFont;    private Font tickFont;	// also used for legend    private Font axisLabelFont;    private boolean showGrid = true;    private static final int outer_border = 6;    private int tick_height;    private int char_width;    private int label_height;    private Applet parent;    // if any.    // save these so can remove/restore them    private MouseAdapter mousePressedListener;    private MouseAdapter mouseReleasedListener;    private MouseMotionAdapter mouseDraggedListener;    private boolean mouseZoomEnabled = false;    public Plot(Dimension size, String x_l, String y_l,                double xMin, double yMin, double xMax, double yMax,                boolean legend, Applet owner) {        super(size.width, size.height);        xmin          = xMin;        ymin          = yMin;        xmax          = xMax;        ymax          = yMax;        truexmin      = xMin;        trueymin      = yMin;        truexmax      = xMax;        trueymax      = yMax;        includeLegend = legend;        x_axis_label  = x_l;        y_axis_label  = y_l;        parent        = owner;        numTraces     = 0;        data          = new Vector(5, 5);        needRepaint   = true;        init();    }    public Plot(Dimension size) {      super(size.width, size.height);      data = new Vector(5,5);      needRepaint = true;      numTraces = 0;      includeLegend = false;      init();    }    public Plot() {      super();      data = new Vector(5,5);      needRepaint = true;      numTraces = 0;      includeLegend = false;      init();    }    public boolean isPlotLegend() { return includeLegend;}    public void setPlotLegend(boolean flag) { includeLegend = flag;}    public int getTickSpacing() { return tick_spacing; }    public void setTickSpacing(int pixels) { tick_spacing = pixels;}    public int getTickLength() { return tick_length; }    public void setTickLength(int pixels) { tick_length = pixels;}    public void setOwner(Applet owner) { parent = owner;}    public void setGridColor(Color c) {gridColor = c;}    public void setAxisColor(Color c) {setForeground(c);}    public int getNumTraces() { return numTraces; }    public DataTrace getTrace(int i) {      return (DataTrace) data.elementAt(i);    }    public void setNeedRepaint(boolean val) {needRepaint = val; }    public void setXAxisLabel(String xlabel) {      x_axis_label = xlabel;      needRepaint = true;    }    public void setYAxisLabel(String ylabel) {      y_axis_label = ylabel;      needRepaint = true;    }    public double getXmin() {return truexmin;}    public double getXmax() {return truexmax;}    public double getCurrentXmin() {return xmin;}    public void setCurrentXmin(double newxmin) {xmin=newxmin; needRepaint = true;}    public double getCurrentXmax() {return xmax;}    public void setCurrentXmax(double newxmax) {xmax=newxmax; needRepaint = true;}    public double getYmin() {return trueymin;}    public double getYmax() {return trueymax;}    public double getCurrentYmin() {return ymin;}    public void setCurrentYmin(double newymin) {ymin=newymin; needRepaint = true;}    public double getCurrentYmax() {return ymax;}    public void setCurrentYmax(double newymax) {ymax=newymax; needRepaint = true;}    public void setXmin(double x) {truexmin = xmin = x; needRepaint=true;}    public void setXmax(double x) {truexmax = xmax = x; needRepaint=true;}    public void setYmin(double y) {trueymin = ymin = y; needRepaint=true;}    public void setYmax(double y) {trueymax = ymax = y; needRepaint=true;}    public synchronized int addTrace(DataTrace dataTrace) {      data.insertElementAt(dataTrace, numTraces);      numTraces++;      needRepaint = true;      return numTraces - 1;    }    public synchronized int addTrace(Color c, String l) {        DataTrace t = new DataTrace();        t.setColor(c);        t.setLabel(l);        return addTrace(t);    }    /** addTrace with these double arrays as data.     */    public synchronized int addTrace(Color c, String l, double[] x, double[] y) {        DataTrace t = new DataTrace();        t.setX(x);        t.setY(y);        t.setColor(c);        t.setLabel(l);        return addTrace(t);    }    public synchronized int addTrace(Color c, String l, int allocate) {        DataTrace t = new DataTrace(allocate);        t.setColor(c);        t.setLabel(l);        return addTrace(t);    }    public synchronized void resetTraceColor(Color c, int trace) {        DataTrace t = (DataTrace) data.elementAt(trace);        t.setColor(c);        needRepaint=true;    }    public void resetRange(double xMin, double yMin,                           double xMax, double yMax) {        xmin          = xMin;        ymin          = yMin;        xmax          = xMax;        ymax          = yMax;        truexmin      = xMin;        trueymin      = yMin;        truexmax      = xMax;        trueymax      = yMax;        needRepaint=true;        if ((area.width > 0) && (area.height > 0))            autoScale();    }    /** reset assumes you're going to use the same traces.  If not,     *  get a new Plot canvas, don't reset this one.     */    public void reset() {        super.reset();        // reset all data traces        for (int i=0; i< numTraces; i++) {            ((DataTrace) data.elementAt(i)).clear();        }        needRepaint=true;    }    public void removeTraces(int begin, int end) {      for (int i=end; i>= begin; i--) {        ((DataTrace) data.elementAt(i)).clear();        data.removeElementAt(i);      }      numTraces = data.size();      MemCleaner.cleanup();      needRepaint = true;    }    /** clear calls reset and removes all traces from the plot */    public void clear() {        super.reset();        data.removeAllElements();        numTraces = 0;    }    public void finalize() {        if (isVisible()) {            setVisible(false);        }        clear();        x_ticks.removeAllElements();        y_ticks.removeAllElements();        super.finalize();    }    private static int[] clippts = new int[4];    public synchronized void addToTrace(int trace, double x, double y) {        DataTrace dt = (DataTrace) data.elementAt(trace);        dt.add(x, y);        if (dt.getNpts() <= 1) return;        int n = dt.getNpts();        clippts[0] = x_pixel(dt.getX(n-2));        clippts[1] = y_pixel(dt.getY(n-2));        clippts[2] = x_pixel(dt.getX(n-1));        clippts[3] = y_pixel(dt.getY(n-1));        Graphics g = getOffscreen();        g.setColor(dt.getColor());	      if (clip(clippts)) {            GraphUtil.doubleLine(g, clippts[0], clippts[1],              clippts[2], clippts[3]);        }    }    /** Ensure we have an offscreen image to draw on.  Don't erase.     */    public Graphics getOffscreen() {        Graphics wasoffg = offg;        offg = super.getOffscreen();        findArea();        if (offg != wasoffg) {            scale();            needRepaint=true;        }        return offg;    }    /** Ensure we have a NEW offscreen image to draw on.     */    protected Graphics newOffscreen() {        Graphics wasoffg = offg;        offg = super.newOffscreen();        findArea();        scale();        needRepaint=true;        return offg;    }    private int maxLegend() {        if (!includeLegend) return 0;        int max = 0;        int thisone;        DataTrace dt;        FontMetrics font = getFontMetrics(tickFont);        char_width       = font.stringWidth("-0123456789") / 11;        for (int i=0; i<numTraces; i++) {            dt = (DataTrace) data.elementAt(i);            thisone = font.stringWidth(dt.getLabel());            if (max < thisone)                max = thisone;        }        return max;    }    private void findArea() {        area.x      = outer_border;        area.x     += maxYLabelLen*char_width; // space for y scaling labels        Dimension amSize = getCurrentSize();        area.width  = amSize.width;        area.width -= 2*outer_border;        area.width -= maxYLabelLen*char_width;        area.width -= (int) 3.5*char_width; // half label at end        area.width -= maxLegend(); // legend to right        area.y      = outer_border;        area.height  = amSize.height;        area.height -= 2*outer_border;        area.height -= tick_height;        if (x_axis_label != null)            area.height -= label_height; // leave space for x axis label        if (y_axis_label != null) {            area.y += label_height;            area.height -= label_height + tick_height;        }    }    public void init()    {      normalFont    = getFont();      tickFont      = new Font("Helvetica", Font.PLAIN, 10);      axisLabelFont = new Font("Helvetica", Font.PLAIN, 12);      FontMetrics font = getFontMetrics(tickFont);      tick_height      = font.getAscent() + font.getLeading();      // getMaxAdvance is huge compared to the characters we actually use.      // Note though we're not going to add '.' into the projected width.      char_width       = font.stringWidth("-0123456789") / 11;      font = getFontMetrics(axisLabelFont);      label_height = font.getHeight();      needRepaint=true;      // add mouse listeners for zooming the plots      // need to save these or no-one can remove them to alter      // mouse meaning over plots.      mousePressedListener = new MouseAdapter() {           public void mousePressed(MouseEvent e) {               start_selection (e.getX(),e.getY());           }      };      this.addMouseListener(mousePressedListener);      mouseDraggedListener = new MouseMotionAdapter() {           public void mouseDragged(MouseEvent e) {            synchronized (selection) {             xorSelection(selection.x, selection.y, selection.width, selection.height);             selection.setSize(e.getX()-selection.x,                               e.getY()-selection.y);             xorSelection(selection.x, selection.y, selection.width, selection.height);            }           }      } ;      this.addMouseMotionListener(mouseDraggedListener);      mouseReleasedListener = new MouseAdapter() {          public void mouseReleased(MouseEvent e) {              end_selection (e.getX(),e.getY());              zoom();              repaint();          }      } ;      this.addMouseListener(mouseReleasedListener);      mouseZoomEnabled = true;    }    public void update (Graphics g) {        paint(g);    }    public synchronized void paint (Graphics g)    {        synchronized (g) {            offg = getOffscreen();            synchronized (offg) {            synchronized (offscreen) {                if ((offg == null) || (offscreen == null))                   return;                if (needRepaint) {                    draw_axes (offg);                    plot_data (offg);                }                if ((offg == null) || (offscreen == null))                   return;                paintBetweenXorFlag = true; // communicate with zoombox                g.drawImage(offscreen, 0, 0, this);            } }        }        needRepaint = false;    }    /** The user has clicked over the plot. Mark Zoom Area */  /* bug fix--how to get a simple rectangle, instead of it getting   * drawn inside out or something....   */  public void xorSelection(int sx, int sy, int sw, int sh) {    if (!paintBetweenXorFlag) {      Graphics g = getGraphics();      g.setXORMode (Color.cyan);      int x1, y1, w, h;      if (sw >= 0) {          x1 = sx;          w  = sw;      } else {          w  = Math.abs(sw);          x1 = sx - w;      }      if (sh >= 0) {          y1 = sy;          h  = sh;      } else {          h = Math.abs(sh);          y1 = sy - h;      }      g.drawRect (x1, y1, w, h);      g.setPaintMode ();    }   paintBetweenXorFlag = false;  }    private void start_selection (int x, int y)    {        paintBetweenXorFlag = false;        Graphics g = getGraphics();        selection = new Rectangle (x,y,0,0);    }    private void end_selection (int x,int y)    {        xorSelection(selection.x, selection.y, selection.width, selection.height);        selection.setSize(x-selection.x,y-selection.y);        paintBetweenXorFlag = false;    }    private Rectangle get_selection() { return selection;}    /** Zooming is enabled on Plots by default, meaning that's what     *  any mousing does over the Plot. This routine allows turning     *  the feature off, and if off, turning it on again.     */    public void setZoom(boolean onFlag) {        // do NOT want multiple listeners set or may get double-zooms        if (mouseZoomEnabled && onFlag)            return;        if (!mouseZoomEnabled && !onFlag)            return;        if (onFlag) {            this.addMouseListener(mousePressedListener);            this.addMouseMotionListener(mouseDraggedListener);            this.addMouseListener(mouseReleasedListener);        } else {            this.removeMouseListener(mousePressedListener);            this.removeMouseMotionListener(mouseDraggedListener);            this.removeMouseListener(mouseReleasedListener);        }        mouseZoomEnabled = onFlag;    }    /** my zoom -- 3 in 1 */    protected void zoom()    {        double new_xmin, new_ymin, new_xmax, new_ymax;        boolean zoomingIn;        int tolerance     = 10;		// moved < 10 pixels == didn't move.        int dx = selection.width;        int dy = selection.height;	       needRepaint = true;        // tiny box == back to whole-scale        if ((Math.abs(dx) < tolerance) || (Math.abs(dy) < tolerance)) {           autoScale();           return;        }        // zoom in--decide based on y alone--up means in, down means out.        if (dy < 0) {            if (parent != null) parent.showStatus ("Zooming in...");            new_ymin = y_value(selection.y);            new_ymax = y_value(selection.y+selection.height);            new_xmin = dx > 0 ?                       x_value(selection.x) : x_value(selection.x+selection.width);            new_xmax = dx > 0 ?                       x_value(selection.x+selection.width) : x_value(selection.x);            if (!validLimits(new_xmin, new_ymin, new_xmax, new_ymax)) {              System.err.println("invalid limit abort");              autoScale();              return;            }            xmin = new_xmin; xmax = new_xmax;            ymin = new_ymin; ymax = new_ymax;            scale();	    return;	}	// if we're still here...this is the hard one.        if (parent != null) parent.showStatus ("Zooming out...");        // let's get the points more convenient--p = pixel coord        int pminx, pmaxx, pminy, pmaxy;        int new_pminx, new_pmaxx, new_pminy, new_pmaxy;        double xscale, yscale;        pminx = dx > 0 ? selection.x : selection.x+selection.width;        pmaxx = dx > 0 ? selection.x+selection.width  : selection.x;        // already know dy > 0, want pmaxy = ur corner        pmaxy = selection.y;        pminy = selection.y + selection.height;        dx = Math.abs(dx);        dy = Math.abs(dy);        xscale = (xmax - xmin) / (double) dx;        yscale = (ymax - ymin) / (double) dy;        // scale origin to ll corner of box        new_xmin = x_value(pminx) - xscale * (double) (pminx - area.x);        new_ymin = y_value(pminy) - yscale * (double) (area.height - pminy);        // scale max to ur corner of box        new_xmax = x_value(pmaxx) + xscale * (double) (area.x + area.width - pmaxx);        new_ymax = y_value(pminy) + yscale * (double) (area.y + area.height - pmaxy);        if (!validLimits(new_xmin, new_ymin, new_xmax, new_ymax)) {          return;        }        xmin = new_xmin; xmax = new_xmax; ymin = new_ymin; ymax = new_ymax;        scale();    }    boolean validLimits(double xlo, double ylo, double xhi, double yhi) {      return ( (xlo < xhi) && (ylo < yhi) );    }    protected void scale()    {        roundScaling();        calculateTickPositions();        needRepaint=true;    }    void autoScale()    {        xmin = truexmin;        ymin = trueymin;        xmax = truexmax;        ymax = trueymax;        scale();    }    /** Used by "zoom" and "autoScale".     * Extends the display region so the x and y axes start and end with a     * labelled tick */    protected boolean roundScalingChanged = false;    protected void roundScaling()    {      roundScalingChanged = false;      double x1 = x_value (x_pixel(xmin)-tick_spacing);      double x2 = x_value (x_pixel(xmax)+tick_spacing);      double y1 = y_value (y_pixel(ymin)+tick_spacing);      double y2 = y_value (y_pixel(ymax)-tick_spacing);      double sxmin = xmin;      double sxmax = xmax;      double symin = ymin;      double symax = ymax;      xmin = round (xmin,x1-xmin); xmax = round (xmax,x2-xmax);      ymin = round (ymin,y1-ymin); ymax = round (ymax,y2-ymax);      // try to permit -4- significant TruncVal.truncVal, only      xmin = TruncVal.truncVal(xmin, 4);      ymin = TruncVal.truncVal(ymin, 4);      xmax = TruncVal.truncVal(xmax, 4);      ymax = TruncVal.truncVal(ymax, 4);      // can't do it...      if (xmin == xmax) {        xmin = sxmin;        xmax = sxmax;      }      if (ymin == ymax) {        ymin = symin;        ymax = symax;      }      roundScalingChanged =    (xmin != sxmin) || (ymin != symin)                            || (xmax != sxmax) || (ymax != symax);      // now, how many fractional digits do we need on each axis?      // set up the formatters      formatX.setMaximumFractionDigits(fracDigitsFor(xmin, xmax));      formatY.setMaximumFractionDigits(fracDigitsFor(ymin, ymax));      needRepaint=true;    }    public NumberFormat getFormatX() { return formatX;}    public NumberFormat getFormatY() { return formatY;}    int fracDigitsFor(double min, double max) {       double spread = Math.abs(max - min);       if (spread > 1000)           return 0;       else if (spread > 100)           return 1;       else if (spread > 10)           return 2;       else if (spread > 1)           return 3;       else           return 4;    }   int sigdigits(double v1, double v2, double vdelta) {    double vrange = v2 - v1;    int order1 = TruncVal.order(v1);    int order2 = TruncVal.order(v2);    int orderr = TruncVal.order(vrange);    int orderd = TruncVal.order(vdelta);    int hiorder= Math.max(order1, order2);    hiorder = Math.max(hiorder, orderr);    int sigdigs = hiorder >= 0 ? hiorder+1 : Math.abs(hiorder);    sigdigs -= orderd;    return sigdigs;   }    void calculateTickPositions()    {      discontinuityFlag = false;      x_ticks.removeAllElements();      y_ticks.removeAllElements();      x_ticksD.removeAllElements();      y_ticksD.removeAllElements();      double x1,x2,xdelta;      x1 = x_value (area.x);      x2 = x_value (area.x+tick_spacing);      x1 = round (x1,x2-x1);      x2 = x_value (x_pixel(x1)+tick_spacing);      x2 = round (x2,x1-x2);      xdelta = round(x2-x1, x2-x1);      xdelta = Math.abs(xdelta);      x2 = x1 + xdelta;      xdelta = TruncVal.truncVal(xdelta, 1); // xdelta always has 1 significant digit (1, 2, 5)      tick_sigdigitsX = sigdigits(x1, x_value(area.x+area.width), xdelta);      x1 = TruncVal.truncVal(x1, tick_sigdigitsX);      x2 = TruncVal.truncVal(x2, tick_sigdigitsX);      if (x_pixel(x1) <= area.x+area.width) {          x_ticks.addElement (new String("" + x1));          x_ticksD.addElement (new Double(x1));      }      // x_pixel == 0 is a discontinuity of some sort, possibly int overflow      while ((x_pixel(x2) <= area.x+area.width) && (x_pixel(x2) != 0))      {        x2 = TruncVal.truncVal(x2, tick_sigdigitsX);        if (x2 == x1) {          autoScale();          return;        }        x_ticks.addElement (new String("" + x2));        x_ticksD.addElement (new Double(x2));        x1 = x2;        x2 = x1 + xdelta;      }      // how many significant digits needed to show correctly?      double y1,y2,ydelta;      y1 = y_value (area.y);      y2 = y_value (area.y+tick_spacing);      y1 = round (y1,y1-y2);      y2 = y_value (y_pixel(y1)+tick_spacing);      y2 = round (y2,y1-y2);      ydelta = round(y2-y1, y2-y1);      ydelta = - Math.abs(ydelta);      y2 = y1 + ydelta;      ydelta = TruncVal.truncVal(ydelta, 1); // ydelta always has 1 significant digit (1, 2, 5)      tick_sigdigitsY = sigdigits(y1, y_value(area.y+area.height), ydelta);      y1 = TruncVal.truncVal(y1, tick_sigdigitsY);      y2 = TruncVal.truncVal(y2, tick_sigdigitsY);      if (y_pixel(y1) >= area.y) {        y_ticks.addElement (new String("" + y1));        y_ticksD.addElement (new Double(y1));      }      while ((y_pixel(y2) <= area.y+area.height) && (y_pixel(y2) != 0))      {        if (y_pixel(y2) >= area.y) {          y2 = TruncVal.truncVal(y2, tick_sigdigitsY);          if (y2 == y1) {            System.err.println("lost precision in y bailout");            autoScale();            return;          }          y_ticks.addElement (new String("" + y2));          y_ticksD.addElement (new Double(y2));        }        y1 = y2;        y2 = y1 + ydelta;      }      maxYLabelLen=1;      // find y label length max      for (int i=0; i<y_ticks.size(); i++) {        String one = (String)y_ticks.elementAt(i);        if (one.length() > maxYLabelLen) maxYLabelLen = one.length() + 1;      }     }    /** Draws a frame arround the plotting area, scaling ticks and labels        and axis labels */    synchronized void draw_axes (Graphics g) {       int width, height, space;       synchronized (g) {            findArea();            calculateTickPositions(); // cart before horse before cart....            g.setPaintMode();            g.setColor (getBackground());            g.fillRect (0,0,getSize().width, getSize().height);            g.setFont(tickFont);            FontMetrics font = g.getFontMetrics();            int minXblank  = g.getFontMetrics().stringWidth(" ");            int tick_height  = font.getHeight(); // for y axis label            String atick;            int lastStringStopped = area.x - 50; // something not a problem            for (int i=0; i < x_ticks.size(); i++) // x axis ticks and labels            {                atick = (String) x_ticks.elementAt(i);		            double x = ((Double) x_ticksD.elementAt(i)).doubleValue();                int px = x_pixel(x), py = area.y+area.height;                if ((showGrid) &&                    (px != area.x) && (py != area.x + area.width)) {                    g.setColor(gridColor);                    g.drawLine(px, py, px, area.y);                    g.setColor(getForeground());                }                g.drawLine (px,py,px,py-tick_length);//                atick = formatX.format(TruncVal.truncVal(x, tick_sigdigitsX));//                atick = formatX.format(x);                width  = g.getFontMetrics().stringWidth(atick);                height = g.getFontMetrics().getAscent();                // to avoid overlap with  axis labels                space  = g.getFontMetrics().getHeight()/2;                // avoid overlapping previous tick label                if (lastStringStopped < px-width/2) {                    g.drawString (atick,px-width/2,py+height+space);                    lastStringStopped = px+width/2+minXblank;                }                py = area.y;                g.drawLine (px,py,px,py+tick_length);            }	           for (int i=0; i < y_ticks.size(); i++) // y axis ticks and labels	           {                atick = (String) y_ticks.elementAt(i);		            double y = ((Double) y_ticksD.elementAt(i)).doubleValue();                int px = area.x, py = y_pixel(y);                if ((showGrid) &&                    (py != area.y) && (py != area.y + area.height)) {                    g.setColor(gridColor);                    g.drawLine(area.x, py, area.x + area.width, py);                    g.setColor(getForeground());                }                g.drawLine (px,py,px+tick_length,py);                width  = g.getFontMetrics().stringWidth (atick);                height = g.getFontMetrics().getAscent();                g.drawString (atick,px-width-2,py+height/2);                px         = area.x+area.width;                g.drawLine (px,py,px-tick_length,py);	         }     	     g.setFont(axisLabelFont);           g.setColor(getForeground());	         font = g.getFontMetrics();          if (x_axis_label != null) { // x axis description            int s = font.getHeight();            int h = font.getAscent();            int w = font.stringWidth (x_axis_label);            int x = area.x+area.width/2-w/2;            int y = area.y+area.height+s/2+s+h;            g.drawString (x_axis_label,x,y);          }	         if (y_axis_label != null) { // y axis description            int s = font.getAscent();            int w = font.stringWidth (y_axis_label);            int x = Math.max (area.x - w/2 - 2,0);            int y = s;            g.drawString (y_axis_label,x,y);          }          // now the legend, if any          DataTrace dt;          int x = area.x + area.width + 2;          int y = area.y;          if (includeLegend) {              g.setFont(tickFont);	         for (int i=0; i < numTraces; i++) {              y += tick_height;	             if (y > area.y + area.height)	                 break;              dt = (DataTrace) data.elementAt(i);              g.setColor(dt.getColor());              g.drawString (dt.getLabel(),x,y);	         }        }        g.setFont(normalFont);        g.setColor(getForeground());        g.drawRect (area.x,area.y,area.width,area.height); // frame      }    }    private void debugClip(DataTrace t, int secondIndex) {      System.err.print("   " + t.getX(secondIndex-1) + "," +        t.getY(secondIndex-1) + " " +        t.getX(secondIndex) + "," +        t.getY(secondIndex) + " --> ");      System.err.println("     " + clippts[0] + "," +      clippts[1] + "  " +      clippts[2] + "," +      clippts[3]);    }    /** Draws the traces inside the "plotting area". If not all, plot latest.    */    private boolean discontinuityFlag = false;    synchronized void plot_data (Graphics g) {       synchronized (g) {          int start;          for (int i=0; i < numTraces; i++) {            discontinuityFlag = false;            DataTrace trace = (DataTrace) data.elementAt (i);            g.setColor (trace.getColor());            clippts[0] = x_pixel(trace.getX(0));            clippts[1] = y_pixel(trace.getY(0));            int n = trace.getNpts();            forpts:            for (int j=1; j < n; j++) { // draw trace                 clippts[2] = x_pixel(trace.getX(j));                 clippts[3] = y_pixel(trace.getY(j));                 if (discontinuityFlag) {                    discontinuityFlag = false;                    if (j==1) {                      clippts[0] = clippts[2];                      clippts[1] = clippts[3];                      continue;                    }                    j++;                    if (j == n)                      break forpts;                    clippts[0]=x_pixel(trace.getX(j));                    clippts[1]=y_pixel(trace.getY(j));                 } else {                    if (clip(clippts)) {                        GraphUtil.doubleLine(g, clippts[0], clippts[1],                                  clippts[2], clippts[3]);                    }                    clippts[0] = clippts[2];                    clippts[1] = clippts[3];                 }            }          }       }    }    /** is this point inside the area on the screen? */    public boolean insideGraph(int pixelx, int pixely) {        if ((pixelx >= area.x) && (pixely >= area.y) &&            (pixelx <= area.x + area.width) &&            (pixely <= area.y + area.height))            return true;        else            return false;    }    /** is this point inside the area on the screen? */    public boolean insideGraph(double realx, double realy) {        int pixelx = x_pixel(realx);        int pixely = y_pixel(realy);        if ((pixelx >= area.x) && (pixely >= area.y) &&            (pixelx <= area.x + area.width) &&            (pixely <= area.y + area.height))            return true;        else            return false;    }    boolean between(int p, int low, int high) {        if ((p >= low) && (p <= high))            return true;        else            return false;    }    /** Returns false if ain't nothing to draw, true otherwise, whether the     *  points needed clipping or not. */    boolean clip(int[] p) {        // let's trust the compiler to optimize these...and use symbolics        int x0 = 0;        int y0 = 1;	// the y's may not be lower and upper, but x's are        int x1 = 2;        int y1 = 3;        int scratch;        float slope, intercept;        boolean vertical = false; // special case, infinite slope        if ( insideGraph(p[x0], p[y0]) &&  insideGraph(p[x1], p[y1]) )            return true;        // put in order in x        int[] inorder = new int[4];        boolean swapped;        if (p[x0] > p[x1]) {            swapped = true;            inorder[0] = p[x1];            inorder[1] = p[y1];            inorder[2] = p[x0];            inorder[3] = p[y0];        } else {            swapped = false;            inorder[0] = p[x0];            inorder[1] = p[y0];            inorder[2] = p[x1];            inorder[3] = p[y1];        }        // find equation of line        slope = ((float)(p[y1] - p[y0])) / ((float)(p[x1] - p[x0]));if (p[x1] == p[x0]) {  vertical = true;}        intercept = (float)p[y1] - slope * p[x1];        // cross left hand side?        if ((inorder[x0] < area.x) && (inorder[x1] > area.x)) {            scratch = (int) Math.round(slope * area.x + intercept);            if (between(scratch, area.y, area.y + area.height)) {                inorder[x0] = area.x;                inorder[y0] = scratch;            }        }        // cross right hand side?        int rhs = area.x + area.width;        if ((inorder[x0] < rhs) && (inorder[x1] > rhs)) {            scratch = (int) Math.round(slope * rhs + intercept);            if (between(scratch, area.y, area.y + area.height)) {                inorder[x1] = rhs;                inorder[y1] = scratch;            }        }        // put in order in y        if (inorder[y0] > inorder[y1]) {            if (swapped) swapped = false; else swapped = true;            scratch = inorder[x0];            inorder[x0] = inorder[x1];            inorder[x1] = scratch;            scratch = inorder[y0];            inorder[y0] = inorder[y1];            inorder[y1] = scratch;        }        // cross top?        if ((inorder[y0] < area.y) && (inorder[y1] > area.y)) {          if (vertical) {            inorder[y0] = area.y;          } else {            scratch = (int) Math.round((area.y - intercept)/slope);            if (between(scratch, area.x, area.x + area.width)) {                inorder[y0] = area.y;                inorder[x0] = scratch;            }          }        }        // cross bottom?        int bot = area.y + area.height;        if ((inorder[y0] < bot) && (inorder[y1] > bot)) {          if (vertical) {            inorder[y1] = bot;          } else {            scratch = (int) Math.round((bot - intercept)/slope);            if (between(scratch, area.x, area.x + area.width)) {                inorder[y1] = bot;                inorder[x1] = scratch;            }          }        }                // put back into p        if (swapped) {            p[x0] = inorder[x1];            p[y0] = inorder[y1];            p[x1] = inorder[x0];            p[y1] = inorder[y0];        } else {            p[x0] = inorder[x0];            p[y0] = inorder[y0];            p[x1] = inorder[x1];            p[y1] = inorder[y1];        }        if ( insideGraph(p[x0], p[y0]) &&  insideGraph(p[x1], p[y1]) )            return true;        else             return false;    }    public boolean discontinuous(double z) {      Double tester = new Double(z);      if (tester.isNaN() || tester.isInfinite()) {        discontinuityFlag=true;        return true;      }      return false;    }    public int x_pixel (double x)    {      if (discontinuous(x)) return 0;      double where = area.x + (x-xmin) / (xmax-xmin) * area.width;      if (where > Integer.MAX_VALUE)        return area.width*10;      else if (where < Integer.MIN_VALUE)        return -area.width*10;      return Math.round(Math.round(where));    }        public int y_pixel (double y)    {      if (discontinuous(y)) return 0;      double where = area.y + area.height - (y-ymin)/(ymax-ymin)*area.height;      int answer;      if (where > Integer.MAX_VALUE)        answer = area.height*10;      else if (where < Integer.MIN_VALUE)        answer = -area.height*10;      else        answer = Math.round(Math.round(where));      return answer;    }    /** Convert screen coordinates to data coordinates */    public double x_value (int x)    {      return (xmin + (xmax-xmin)*(x-area.x)/area.width);    }    public double y_value (int y)    {      return (ymin - (ymax-ymin)*(y-area.y-area.height)/area.height);    }        /** used for axis labeling */    double round (double value, double range)    {      if (range == 0) return value;      boolean round_up = true;       if (range < 0) round_up = false;      range = Math.abs(range);      double step = (float) Math.pow (10,Math.floor(Math.log(range)/Math.log(10.)));      if (step*5 <= range) step*=5;      if (step*2 <= range) step*=2;      if (round_up) value = (double) Math.ceil (value/step) * step;      else value = (double) Math.floor (value/step) * step;      return value;    }        public String toString() {        DataTrace dt;        String retstring = "Plot[x=" + x_axis_label + ",y="             + y_axis_label + ",traces[";        Enumeration e = data.elements();        while (e.hasMoreElements()) {            dt = (DataTrace) e.nextElement();            retstring = retstring + dt + ",";        }        retstring = retstring + "]]";        return retstring;    }}