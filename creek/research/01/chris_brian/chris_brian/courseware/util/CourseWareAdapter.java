/* * * @(#)CourseWareAdapter.java 0.2 98/05/01 * * Copyright (c) 1998 Ginger Booth.  All Rights Reserved. * * @history: A class to subclass for CourseAware interface. * @author Ginger Booth * @version 0.2, 98/04 */package courseware.util;import java.applet.*;import java.awt.*;import java.awt.event.*;import java.lang.Math;public class CourseWareAdapter extends Panel implements CourseWare {  private CourseWare parent = null;  private Palette palette = null;  private boolean paletteDone = false; // flag to keep palette between scenes  /** Just calls super() to make the Panel. */  public CourseWareAdapter() {    super();  }  /** Sets parent. */  public void setOwner(CourseWare a) {    parent = a;  }  public CourseWare getOwner() { return parent; }  public Container getContainer() { return getParent();}  public CourseWareApplet cwaOwner() { return (CourseWareApplet) parent; }  public ExecButton getScenarioButton() { return cwaOwner().getScenarioButton(); }  public void setPalette(Palette p) { palette = p;}  public Palette getPalette() { return palette; }  public Param getParam(String name) {return parent.getParam(name);}  /** Has defaults.  Sets layout management to ModuleLayout   *  and adds this panel to parent correctly.  Doesn't call   *  doLayout(), since at this point, there's no layout to   *  be done.  If you've used this default (or super.init() in   *  your init), you can use the makeButton mechanism to    *  autogenerate all your user dialogs.   */  public void init() {    int padding = 2;    ModuleLayout ml = new ModuleLayout(1);    int pad = CoursePanel.getPadding();    ml.setOptions(10, pad, pad, false);    setLayout(ml);    parent.add(BorderLayout.CENTER, this);  }    /** has default:  any params in this list which refer to my class,   *  bind them to call me on execution.  In other words, does:   *         p.bindAllObjects(this.getClass(), this);    *  If some of classes which this class instantiates have    *  params that are set directly from the parameter input file,   *  this routine must be subclassed to bind them, too.  For   *  instance, say we create Workhorse w, with gobs of   *  fiddly parameters we would like it to set for itself, leaving   *  only menu parameters or logic at the top level CourseAware.    *  Then our CourseWareAdapter subclass   *  would have:   *           public void bindParams(ParamList p) {   *                super.bindParams(p);   *                p.bindAllObjects(w.getClass(), w);    *           }   *           */  public void bindParams(ParamList p) {    p.bindAllObjects(this.getClass(), this);   }  /** No default.  May not need to do anything. */  public void start() { }  /** No default. May not need to do anything. */  public void clear() {}    /** No default. */  public void stop() {}  /** Must call super.finalize() as a minimum.  So does. */  public void finalize() {     try {        super.finalize();    } catch (Throwable t) {}  }    /** makeButton is NOT part of the CourseAware interface, but it's   *  a useful utility iff you're using params and ModuleLayout.   *  This takes any param list by name and creates a button of   *  that name to popup a dialog to set the values of that list   *  of params.  This routine is often called by parameter itself,   *  using a construct in the parameter input file like:   *     ParamList "Pen" {   *         nibWidth "Nib width" = 16   *         nibAngle "Nib angle" = 45.0   *     }   *     makeButton "Pen" = "Pen"   *   *  This creates a button labeled "Pen" which pops up a dialog   *  to set nib width and angle, with OK and Cancel buttons,    *  with the button added to the first ModuleLayout button area.   *  If a button named "Pen" already exists, it is replaced.   */  public void makeButton(String paramListName) {    ParamList theList = (ParamList) parent.getParam(paramListName);    if (theList == null) {        System.err.println("Couldn't find params to makeButton(" +             paramListName + ")");        return;    }    makeButtonCommon(theList);  }    /** Similarly, makePalette to autogenerate a bunch of colors with    *  names is just a simple utility.  Override to use more complex   *  features of Palette.  Replaces whatever palette was in use   *  before.  Use addToPalette to add to prior palette.   */  public void makePalette(int num, int colorscheme) {    if (paletteDone) return;    palette = new Palette(num, colorscheme);  }  /** Ignore all further calls to makePalette, addToPalette. The default is   *  to make a new palette for each scenario, which can be annoying if you   *  don't want that. Can't make keeping the palette the default, because   *  don't know ahead of time when its setup is going to be finished.   */  public void keepPalette() {    paletteDone = true;  }    /** This version adds a slew of colors a la makePalette, and merges   *  them in. Names are uniquified.   */  public void addToPalette(int num, int colorscheme) {    if (paletteDone) return;    Palette p2 = new Palette(num, colorscheme);    palette.merge(p2, false);  }  public void newPalette() { palette = null; }    /** This version adds one RGB color. No name uniquify. If no palette   *  yet, creates one.   */  public void addToPalette(String name, int r, int g, int b) {    if (paletteDone) return;    if (palette == null)        palette = new Palette();    palette.addColorRGB(r, g, b, name);  }    /** The palette doesn't exist in the parameter file by name.  To   *  get a button allowing the user to intervene, on current palette...   */  public void makePaletteButton(String label, int rgbflag) {    if (palette == null)         return;    ParamList colorParams = ColorParam.paramsForPalette(label, palette,(rgbflag==0));    makeButtonCommon(colorParams);  }    /** used by makeButton and makePaletteButton */  protected void makeButtonCommon(Param theList) {    // check if we already have such a button....    int numComps = getComponentCount();    for (int i = 0; i<numComps; i++) {        Component c = getComponent(i);        if (c instanceof ExecButton) {            ExecButton ec = (ExecButton) c;            if (theList.name.equals(ec.getLabel())) {                ec.setVisible(false);                remove(ec);                i--;                numComps--;            }        }    }    ExecButton eb = new ExecButton(theList.name, theList,        ParamDialog.WITH_BOTH_BUTTONS);    this.add(eb, ModuleLayout.BUTTONLIST_STRING);    this.setVisible(true);    ModuleLayout ml = (ModuleLayout) getLayout();    ml.setConstraint(eb, 0, ModuleLayout.BUTTONLIST);  }  /** for Java, not param file */  public MatchedButton makeButton(String name, int whichSlice, Param theList) {    // check if we already have such a button....    int numComps = getComponentCount();    for (int i = 0; i<numComps; i++) {        Component c = getComponent(i);        if (c instanceof Button) {            Button ec = (Button) c;            if (name.equals(ec.getLabel())) {                ec.setVisible(false);                remove(ec);                i--;                numComps--;            }        }    }    ModuleLayout ml = (ModuleLayout) getLayout();    if (theList == null) {      MatchedButton b = new MatchedButton(name);      this.add(b, ModuleLayout.BUTTONLIST_STRING);      b.setVisible(true);      ml.setConstraint(b, whichSlice, ModuleLayout.BUTTONLIST);      return b;    }    ExecButton eb = new ExecButton(name, theList,        ParamDialog.WITH_BOTH_BUTTONS);    this.add(eb, ModuleLayout.BUTTONLIST_STRING);    eb.setVisible(true);    ml.setConstraint(eb, whichSlice, ModuleLayout.BUTTONLIST);    return eb;  }  /** comment(msg) is another utility to put messages in the comment   *  area of the CourseWareApplet.   */   public void comment(String msg) {parent.comment(msg);}  /** This weirdness is because Netscape won't allow finding a method for the   *  module and invoking it from CourseWareApplet. Hence, we need to execute   *  a method named in module's interface to get at them.   */  public void moduleMethod(String methodName) {    System.err.println("moduleMethod: no such method: " + methodName);  }  public void moduleMethodArgs(String methodName, String args) {    System.err.println("moduleMethod: no such method: " + methodName + "("+args+")");  }  /** Cannot be put in superclass, but may find useful.  If your   *  display is flickering, it's often because Java by default is   *  erasing the screen too often.  Consider using:   *   *    public void update (Graphics g) { paintComponents(g); }   */}