/* * * @(#)Palette.java 1.0+ 990325 * * Copyright (c) 1997-1998 Ginger Booth.  All Rights Reserved. * * @history: 980504, vfb, revamp, note default palette is now empty, * @history               and colors no longer contain data fields. * @history: original * @author Ginger Booth * @version 0.1, August 1997 * @version 1.0+, Mar99, move out all but basic color generators */package courseware.util;/** Generate collection of colors, various dimness levels, but all rainbow. */import java.awt.*;import java.util.*;import java.lang.reflect.*;public class Palette implements Palettable {        private Vector colors = new Vector(); // members are ColorObj    private int currentColor = 0;         // currently selected color (def 0)        // color schemes you may request--"merge" multiple palettes to mix        // these all refer to rainbows, basically    public static final int DEFAULT= 0;    public static final int BRIGHT = 1;    public static final int PASTEL = 2;    public static final int DIM    = 3;    public static final int DARK   = 4;    public static final int WEBMID = 5;    // Hues are not an even progression--near the color guns, -broad- span    // that's indistinguishable as different colors--this is a kludgy first    // pass at dealing with that.    public  static float greenskip = .14f;    public  static float blueskip  = .08f;    public  static float greenbegin= .26f;    public  static float greenend  = .40f;    public  static float turqbegin = .5f;    public  static float bluebegin = .64f;    public  static float blueend   = .72f;    public  static float huelow    = .025f;// redskip, in effect    public  static float huehigh   = .91f; // magenta (looks like red)    public  static float brightbright = 1.0f;    public  static float defbright    = 0.9f;    public  static float dimbright    = 0.75f;    public  static float darkbright   = 0.6f;    /** one empty palette, ready to populate through addColorRGB and     *  addColorHSB. */    public Palette() {    }    /** custom palette--see PaletteNamer for a hue decoder.  Basically, gives     *  requested number of colors, brightness per colorscheme, and saturation     *  ranging from satbegin to satend.     */    public Palette(int num, int colorscheme, float hue,                   float satbegin, float satend) {        this();        float    sat, satdelta;        float    bright    = defbright;        switch (colorscheme) {            case DEFAULT: break;            case DIM    : bright = dimbright; break;            case BRIGHT : bright = brightbright; break;            case PASTEL : bright = brightbright; break;            case DARK   : bright = darkbright; break;            default : break;        }        hsbRun(num, satbegin, satend, hue, hue, bright, bright);    }    /** custom palette--see makeName for a hue decoder.  Basically, gives     *  requested number of colors, brightness & sat per colorscheme, and     *  hue ranging from huebegin to hueend.  No skips here--suggest the     *  user avoid the skip ranges in Palette(num, colorscheme).     */    public Palette(int num, int colorscheme, float huebegin, float hueend) {        this();        float    bright    = .75f;        float    sat       = 1.0f;        switch (colorscheme) {            case DEFAULT: break;            case DIM    : bright = dimbright; break;            case DARK   : bright = darkbright; break;            case BRIGHT : bright = 1.0f; break;            case PASTEL : sat    = 0.4f; bright = 1.0f; break;        }        hsbRun(num, sat, sat, huebegin, hueend, bright, bright);    }    private void hsbRun(int num, float satbegin, float satend,                float huebegin, float hueend, float brightbegin, float brightend) {        float hue      = huebegin;        float huedelta = Math.abs(huebegin - hueend)/(float)(num - 1f);        float sat      = satbegin;        float satdelta = (satend - satbegin) / (float)(num - 1f);        float bright   = brightbegin;        float brightdelta = (brightend - brightbegin) / (float)(num - 1f);        for (int i=0; i < num; i++) {            addColor(Color.getHSBColor(hue, sat, bright), null);            hue += huedelta;            sat += satdelta;            bright += brightdelta;        }    }    // max number is 10.    public void webIntermediate(int number) {      if (number > 5)        addColor(new Color(255, 0, 153), null); // fuschia      addColor(new Color(255, 51, 0), null);  // scarlet      if (number > 6)        addColor(new Color(255, 153, 0), null); // orange      if (number > 7)        addColor(new Color(204, 102, 102), null); // coffee      addColor(new Color(255, 255, 102), null); // yellow      if (number > 9)        addColor(new Color(102, 102, 102), null); // grey      addColor(new Color(0, 153, 51), null); // green      if (number > 8)        addColor(new Color(0, 153, 153), null); // bluegreen      addColor(new Color(0, 102, 255), null); // blue      addColor(new Color(153, 51, 255), null); // purple    }    public Palette(int number, int colorscheme)    {        this();        if (number < 1) return;        float    hue, huedelta;        float    sat       = 1.0f;        float    bright    = defbright;        switch (colorscheme) {            case DEFAULT: break;            case DIM    : bright = dimbright; break;            case DARK   : bright = darkbright; break;            case BRIGHT : bright = 1.0f; break;            case PASTEL : sat    = 0.4f; bright = 1.0f; break;            case WEBMID : this.webIntermediate(number); return;         }        hue      = huelow;        huedelta = (huehigh - huelow - greenskip - blueskip)/(float)(number - 1f);        for (int i=0; i < number; i++) {            addColor(Color.getHSBColor(hue, sat, bright), null);            hue += huedelta;            if ((hue > .26) && (hue < .40))                hue += greenskip;            if ((hue > .64) && (hue < .72))                hue += blueskip;        }    }    /** Atomize for gc to collect. */    public void finalize() {        colors.removeAllElements();        try {            super.finalize();        } catch (Throwable t) {};    }    public int getNumColors() {        return colors.size();    }    public Color getColor(int i) {        ColorObj co = (ColorObj) colors.elementAt(i % colors.size());        return co.color;    }    public void setColor(int i, Color c) {        ColorObj co = (ColorObj) colors.elementAt(i % colors.size());        co.color = c;    }        public void setCurrentColor(int i) {        currentColor = i % colors.size();    }        public Color getCurrentColor() {        return getColor(currentColor);}    public int getCurrentColorId() {        return currentColor;}    public String getName(int i) {        ColorObj co = (ColorObj) colors.elementAt(i);        return co.name;    }    public void setName(int i, String s) {        ((ColorObj) colors.elementAt(i)).name = s;    }    public ColorObj getColorObj(int i) {        return (ColorObj) colors.elementAt(i);    }    /** Returns index into palette of newly added color. */    public int addColorHSB(float h, float s, float b, String n) {        return addColor(Color.getHSBColor(h, s, b), n);    }    /** Returns index into palette of newly added color. */    public int addColorRGB(int r, int g, int b, String n) {        return addColor(new Color(r, g, b), n);    }    public int addColor(Color c, String n) {        ColorObj oneColorObj = new ColorObj(c, n);        colors.addElement(oneColorObj);        return colors.indexOf(oneColorObj);    }    /** Remove any color from the palette that contains this substring.     *  Like, yellow or pink, if you need it readable on a grey background.     */    public void pruneSubName(String substring)    {        Vector newcolors = new Vector();        for (int i=0; i < colors.size(); i++) {            if (((ColorObj) colors.elementAt(i)).name.indexOf(substring) < 0) {                newcolors.addElement(colors.elementAt(i));                i++;            }        }        colors = newcolors;    }    public void remove(int i) {       colors.removeElementAt(i);       colors.trimToSize();       if (currentColor > colors.size() - 1)           currentColor = 0;    }    /** Return colors index of first ColorObj containing this substring.     *  Like, some green in the current palette. -1 if none.     */    public int findSubName(String substring)    {        ColorObj o;        for (int i=0; i < colors.size(); i++) {            o = ((ColorObj) colors.elementAt(i));            if (o.name == null) break;            if (o.name.indexOf(substring) > -1) {                return i;            }        }        return -1;    }    /** Return colors index of first ColorObj matching this string.     *  -1 if none.     */    public int findName(String target)    {        ColorObj o;        for (int i=0; i < colors.size(); i++) {            o = ((ColorObj) colors.elementAt(i));            if (o.name == null) break;            if (o.name.equals(target)) {                return i;            }        }        return -1;    }    public void swap(int c1, int c2)    {        Object co1, co2;        co1 = colors.elementAt(c1);        co2 = colors.elementAt(c2);        colors.setElementAt(co2, c1);        colors.setElementAt(co1, c2);    }    /** Appends otherPalette to this Palette, removing all the elements     *  from otherPalette (it is consumed).  Colors with duplicate names     *  are optionally discarded, and the number of colors remaining is     *  returned.     */    public int merge(Palette otherPalette, boolean skipDupName)    {        Vector v1   = colors;        Vector v2   = otherPalette.colors;        String n2;        ColorObj candidate, other;        int i, j;        boolean dup;        int startnum = v1.size();        for (i=0; i < v2.size(); i++) {            candidate = (ColorObj) v2.elementAt(i);            dup = false;          duploop:            for (j=0; j < startnum; j++) {                other = (ColorObj) v1.elementAt(j);                if ((candidate.name !=null) && (other.name!=null) &&                    candidate.name.equals(other.name)) {                    dup = true;                    break duploop;                }            }            if (skipDupName) {                if (!dup)                    v1.insertElementAt(candidate, v1.size());            } else                v1.insertElementAt(candidate, v1.size());        }        // since in C++, we learned to be paranoid about auto-disposers...        for (i=v2.size() - 1; i >= 0; i--) {            v2.removeElementAt(i);        }        return v1.size();    }} /* Palette */