/* * * @(#)ParamMgr.java 0.3 99/02/23, vfb * * Copyright (c) 1998-1999 Ginger Booth.  All Rights Reserved. * * @history: original * @author Ginger Booth * @version 0.2, April 1998 * @version 0.3, February 1999, gut and rewrite. *//** Warning: The ParamMgr *  cannot read longs correctly due to a fundamental flaw in StreamTokenizer *  and Double/Long. Note that though Double has a routine named "doubleToLongBits", *  it does not return the double interpreted as a long, but...something else. *  Rather than fix all that, which I'm not sure how to do, I seed random *  number generators with int, and don't use longs anywhere else. */package courseware.util;import java.io.*;import java.net.URL;import java.lang.reflect.*;import java.util.*;import java.applet.*;import java.net.*;import java.awt.*;public class ParamMgr {    private ParamBlock globals;    private Vector blocks;    // of ParamBlock    private Vector scenarios; // of ParamBlock    static  ParamBlock buildingBlock; // current block of params abuilding    public static boolean DEBUGON = false;    // This for runtime, not parsetime. What's executing.    private ParamList currentPublicList = null;    private Method setScenarioMethod;    // sections of input file    private static final String globalsKeyword      = "GLOBALS";    private static final String scenarioKeyword     = "SCENARIO";    private static final String paramListKeyword    = "PARAMLIST";    // modifiers on a parameter--result in non-normal params    private static final String javaParamKeyword    = "JAVAPARAM";    private static final String insertListKeyword   = "INSERTLIST";    private static final String immediateKeyword    = "IMMEDIATE";    private static final String insertFileKeyword   = "INSERTFILE";    // return values for isParamType(String)    private static final int NORMALPARAM = 0;    private static final int JAVAPARAM   = 1;    private static final int INSERTLIST  = 2;    private static final int IMMEDIATEPARAM = 3;    // misc keywords    private static final String newKeyword          = "NEW";    private static final String falseKeyword        = "FALSE";    private static final String trueKeyword         = "TRUE";    private static final String nullKeyword         = "NULL";    // directive in input file    private static final String paramVerboseKeyword = "PARAMVERBOSE";    static CourseWare CWA;    static Class CWAClass;    private URL url;                  // URL we were invoked on    private boolean verboseFlag = false;    // hash tables to reduce slow lookups, esp. for fileNotFound....    private Hashtable hashFound;    private Hashtable hashNotFound;    // error string bits    private static final String MALSCENE = "Malformed Scenario--expected 'Scenario(\"name\")'";    private static final String MALINSERT = "Malformed insertFile--expected 'insertFile(\"filename\")'";    private static final String EXPECTED = "expected ";    private static final String NOTALLOWED = "not allowed ";    private static final String LABELNOTALLOWED = "Label " + NOTALLOWED;    private static final String PARAMNAMENOTALLOWED = "Parameter name " + NOTALLOWED;    private static final String CLASSNOTFOUND = "Class not found ";    private static final String EXPECTEDJAVAPARAM = EXPECTED + "javaParam(\"s1\", \"s2\")";    private static final String EXPECTEDINSERTLIST = EXPECTED + "insertList(\"paramListName\")";    private static final String METHODNOTFOUND = "Method not found" ;    private static final String BADNEWOBJECT = "Malformed object assignment";    private void init() {      hashFound    = new Hashtable();      hashNotFound = new Hashtable();      try {        globals = new ParamBlock(globalsKeyword, null, false, false);      } catch (Exception e) {}      scenarios = new Vector(5,5);      blocks = new Vector(5,5);      currentPublicList = null;      buildingBlock = null;      try {        setScenarioMethod = this.getClass().getMethod("setScenario", new Class[] { String.class });      } catch (Exception e) {}    }    private void cleanup() {      // let these globals go....      hashFound = null;      hashNotFound = null;      stok = null;      blocks = null;      // DON'T, in case there are no scenarios : globals = null;      buildingBlock = null;      for (int i=0; i<scenarios.size(); i++) {        ParamBlock pb = (ParamBlock)scenarios.elementAt(i);        pb.context = null;      }    }    /** Read parameters from file, building Param/List structures.     *  CourseWareApplet's params (and only CWA's params) are prebound.     *  ParamMgr does not apply params.     */    public ParamMgr(URL url, CourseWare cwa)        throws ParameterFileFormatException    {      this.url = url;      CWA = cwa;      if (cwa != null) {        CWAClass = cwa.getClass();      }      if (cwa instanceof Applet)        Param.applet=(Applet)cwa;      init();      parse(url);      if (scenarios.size() == 0)        currentPublicList = globals.params;      else {        ParamList currentScenario = ((ParamBlock) scenarios.elementAt(0)).params;        currentPublicList = (ParamList) currentScenario.cloneRecursive();      }      cleanup();      if (verboseFlag)        masterListDump();    }    /** Make a Scenario button that pops a list of scenarios for the     *  user to choose from.  Give it back to the caller to put on     *  the user interface somewhere.  Caller should call button.show().     */    public ExecButton makeScenarioButton(String label) {        ParamList choiceList = new ParamList("Scenarios");        for (int i=0; i<scenarios.size(); i++)          choiceList.add(            makeScenarioExecParam(              ((ParamBlock)scenarios.elementAt(i)).params ) );        return new ExecButton(label, choiceList,            ParamDialog.WITH_CANCEL_BUTTON);    }    private ExecParam makeScenarioExecParam(Param p) {      return new ExecParam(p.name,            new Object[] {p.name}, this, setScenarioMethod);    }    /** if scenario doesn't exist, currentScenario becomes null */    public void setScenario(String s) {      ParamBlock pb = ParamBlock.findInVector(scenarios, s);      if (pb == null)        currentPublicList = null;      else {        currentPublicList = (ParamList) pb.params.cloneRecursive();      }      CWA.stop();      CWA.start();    }    public Param getParameter(String which) {      return (currentPublicList==null) ? null : currentPublicList.find(which, false);    }    public ParamList getParameters() {return currentPublicList;}    public int getNumScenarios() { return scenarios.size();}    private ParamBlock getScenarioBlock(int i) { return ((ParamBlock) scenarios.elementAt(0));}    /** *sigh* this information is needed by ParamDialog, when it's rewritten     *  to use the Dialog rather than Frame class--attempted kludge around     *  Linux frames failing to show anything inside popup.     */    public static Frame getMasterFrame() {      if (CWA == null)        return null;      Container framefinder = CWA.getContainer();      while ( framefinder != null) {        if (framefinder instanceof Frame)          return (Frame)framefinder;        framefinder = framefinder.getParent();      }      return null;    }    private StreamTokenizer stok;    private URL saveURL;    // just for error messages    // where are we...?    private static final int STATUS_OUTOFBLOCK    = 0;    private static final int STATUS_INGLOBALS     = 1;    private static final int STATUS_INBLOCKPARAMS = 2;    private static final int STATUS_INSCENARIO    = 3;    private int statusInWhat;    private void parse(URL url) throws ParameterFileFormatException    {        saveURL = url;        // open the URL stream tokenizer        try {            stok = new StreamTokenizer(               new InputStreamReader( url.openStream() ) );        } catch (Exception e) {            throw parseError(e.getMessage());        }        // set up the tokenizer to recognize my tokens        // all char's I'd like parsing to return with one-char, not part of word        stok.ordinaryChar('{');        stok.ordinaryChar('}');        stok.ordinaryChars(':', ';');        stok.ordinaryChar(',');        stok.ordinaryChars('(', ')');        stok.ordinaryChar('=');        stok.slashSlashComments(true);        stok.eolIsSignificant(false);        // kick off recursive parsing        readParam(null);    }    void onedump(String title, ParamBlock list) {      if (list == null)        System.err.println(title + " is a null list");      System.err.println("\n"+title+":");      list.params.debugList();    }    public void masterListDump() {        verboseFlag = false; // no looping, please....        onedump("Globals", globals);        if (blocks != null)          for (int i=0; i<blocks.size(); i++)            onedump("BlockParams", (ParamBlock) (blocks.elementAt(i)) );        if (scenarios != null)          for (int i=0; i<scenarios.size(); i++)            onedump("Scenario", (ParamBlock) (scenarios.elementAt(i)) );        if (currentPublicList != null) {          System.out.println("\n\nCurrent Scenario:");          currentPublicList.debugList();        }        verboseFlag = true; // only if succeeded....    }    // does the directive as well as checking it    private boolean isDirective(StreamTokenizer stok) {      return verboseFlag = stokEquals(paramVerboseKeyword) ;    }    /** if current list changes, return new list, else null */    private ParamList isScenarioList(String firstWord, StreamTokenizer stok, String theLabel)                      throws ParameterFileFormatException    {        if (!strEquals(firstWord, scenarioKeyword)) return null;//        if (statusInWhat != STATUS_OUTOFBLOCK) throw parseError("Nesting " + NOTALLOWED);        buildingBlock   = new ParamBlock("", globals, true, true);        scenarios.addElement(buildingBlock);        statusInWhat = STATUS_INSCENARIO;        // OK, if Scenario, need ("name") {        if (stok.ttype == '(') {          if (getNeeded('"', stok)) {            buildingBlock.params.name = stok.sval;            if (getNeeded(')', stok)) {              if (getNeeded('{', stok)) {                // labels not allowed on scenario lists                if (theLabel != null)                  throw parseError(LABELNOTALLOWED);                // cool, done.                return buildingBlock.params;        } } } }        throw parseError(MALSCENE);    }    /** true if it was--this routine processes the inserted file and adds     *  its scenarios ONLY to the scenarios here. No scoping--the scenarios     *  are complete and unalterable by the inserter. (No label override, etc.)     */    private boolean isInsertFile(String firstWord, StreamTokenizer stok, String theLabel)                      throws ParameterFileFormatException    {      if (!strEquals(firstWord, insertFileKeyword))        return false;      if (statusInWhat != STATUS_OUTOFBLOCK)        throw parseError("Nesting " + NOTALLOWED);      // need ("filename") {  , where filename simply relative to the html      // file that launched us. This routine adds "file:" part to URL.      String filename = null;      if (stok.ttype == '(') {        if (getNeeded('"', stok)) {          filename = new String(stok.sval);          if (getNeeded(')', stok)) {            if (getNeeded('{', stok)) {              // labels not allowed on scenario lists              if (theLabel != null) {                throw parseError(LABELNOTALLOWED);      } } } } }      if (filename == null)        throw parseError(MALSCENE);      ParamMgr subreader;      try {        URL paramsURL = new URL(url, filename);        /*        if (CWA instanceof Applet)          paramsURL = new URL( ((Applet) CWA).getDocumentBase(), filename);        else          paramsURL = new URL("file:" + filename);        */        subreader = new ParamMgr(paramsURL, CWA);      } catch (MalformedURLException e) {        throw parseError(e.getMessage());      }      if (subreader.getNumScenarios() == 0)        throw parseError("inserted file had no scenarios--no effect!");      for (int i=0; i<subreader.getNumScenarios(); i++)        scenarios.addElement(subreader.getScenarioBlock(i));      return true;    }    /** if buildingBlock changes, return new list, else null */    private ParamList isGlobalList(String firstWord, StreamTokenizer stok, String theLabel)                      throws ParameterFileFormatException    {      if (!strEquals(firstWord, globalsKeyword)) return null;      if (statusInWhat != STATUS_OUTOFBLOCK)        throw parseError("Nesting " + NOTALLOWED);      statusInWhat = STATUS_INGLOBALS;      globals = new ParamBlock(globalsKeyword, null, false, false);      buildingBlock = globals;      if (stok.ttype != '{')        throw parseError(EXPECTED + "{.");      if (theLabel != null)        throw parseError(LABELNOTALLOWED);      return globals.params;    }    private boolean stokEquals(String upperval) {      return strEquals(stok.sval, upperval);    }    private boolean strEquals(String source, String upperval) {      String upper = new String(source);      upper = upper.toUpperCase();      return upper.equals(upperval);    }    /** advance token only if c is found next */    private boolean getNeeded(char c, StreamTokenizer stok) {      try {        int token = stok.nextToken();        if (token == c) {          return true;        } else {          stok.pushBack();          return false;        }      } catch (Exception e) {      }      return false;    }    /** is a ParamList, make one--this doesn't change the buildingBlock */    private ParamList isParamList(String firstWord, StreamTokenizer stok,                                  ParamList whereToAdd, String theLabel)                      throws ParameterFileFormatException {      if (!strEquals(firstWord, paramListKeyword)) return null;      ParamList pl = new ParamList();      if ( whereToAdd == null ) {//      if ( (whereToAdd == null) || (statusInWhat == STATUS_OUTOFBLOCK) ) {        buildingBlock = new ParamBlock("", globals, false, true);        blocks.addElement(buildingBlock);        pl = buildingBlock.params;        statusInWhat = STATUS_INBLOCKPARAMS;      } else {        pl = new ParamList();        whereToAdd.add(pl);      }      if (theLabel != null)        buildingBlock.addLabel(theLabel, pl, whereToAdd);      try {        // There are four possible forms here....        // 1. ParamList {        if (stok.ttype == '{') {          return pl;        }        // 2. ParamList() {        if (stok.ttype == '(') {          // 3. ParamList("name") {          if (stok.nextToken() == '"') {            pl.name = stok.sval;            // 4. ParamList("name", "class.method") {            if (stok.nextToken() == ',') {              if (stok.nextToken() != '"') {                throw parseError(EXPECTED + "\"class.method\".");              } else {                setClassAndMethod(pl, stok.sval);                stok.nextToken();              }            }          }         if (stok.ttype == ')')            if (getNeeded('{', stok))              return pl;        }      } catch (Exception e) {}      throw parseError("Malformed ParamList.");    }    /** Parsing a declaration, handle what comes after = */    private void setObject(CorlDeclare dec, StreamTokenizer stok)                      throws ParameterFileFormatException,                      InstantiationException, IllegalAccessException,	                    IllegalArgumentException, InvocationTargetException    {      // alright, two possibilities allowed:      // 1. Full.Class.Name fcn = new Constructor(args);      // 2. Full.Class.Name fcn = other.getSomething(args);      int token;      try {        if ( (token = stok.nextToken()) == stok.TT_WORD) {          // case 1. new ClassName(args)          if (stokEquals(newKeyword)) {            token = stok.nextToken();            if ( token != stok.TT_WORD)              throw parseError(BADNEWOBJECT);            String classname = stok.sval;            Class constructorClass = lookupClass(classname);            if (constructorClass == null)              throw parseError(CLASSNOTFOUND + ", constructor ");            Constructor[] constructors = constructorClass.getConstructors();            Constructor theConstructor = null;            if (constructors.length == 0)              throw parseError(BADNEWOBJECT + ", constructor ");            token = stok.nextToken();            Vector args = readArgList(stok);            Object[] realargs = null;            sortIntsForward(constructors);            for (int i=0; i<constructors.length; i++) {              realargs = signatureMatches(constructors[i].getParameterTypes(), args);              if (realargs != null) {                theConstructor = constructors[i];                break;              }            }            if (theConstructor == null)              throw parseError(BADNEWOBJECT + ", constructor ");            Object newObject;            try {              newObject = theConstructor.newInstance(realargs);            } catch (InvocationTargetException e) {              System.err.println(e);              System.err.println(e.getTargetException());              throw parseError(e.getMessage());            }            dec.type = CorlDeclare.CORL_OBJECT;            dec.target = newObject;            if ( (token = stok.nextToken()) != ';')              throw parseError(BADNEWOBJECT);            return;          }          // case 1 outta here          // now for case 2, most like an xxx.getSomething(args)          //    cannot do this unless xxx is also a CORL_OBJECT          //    OR method is static....          if ( (token = stok.nextToken()) != stok.TT_WORD)            throw parseError(BADNEWOBJECT);          String classname = classPart(stok.sval);          CorlDeclare otherdec = buildingBlock.context.getDec(classname,                         buildingBlock.context.classes);          if (dec == null) throw parseError(BADNEWOBJECT);          Object target = otherdec.target; // could still be null          String methodname = stok.sval.substring(classname.length()+1, stok.sval.length());          Vector args = readArgList(stok);          Class theClass = (Class) otherdec.value;          Method theMethod = null;          Object[] realargs = null;          // is/are such-named method(s) available?          Method[] allMethods = theClass.getMethods();          Vector possibleMethods = new Vector(2,2);          for (int j=0; j < allMethods.length; j++) {            if ( allMethods[j].getName().equals(methodname) ) {              possibleMethods.addElement(allMethods[j]);            }          }          sortIntsForward(possibleMethods);          for (int j=0; j<possibleMethods.size(); j++) {            theMethod = (Method) possibleMethods.elementAt(j);            realargs = signatureMatches(theMethod.getParameterTypes(), args);            if (realargs != null) {              if ( ((Class)dec.value).isAssignableFrom(                    theMethod.getReturnType() ) )                break;              else theMethod=null;            }          }          if (theMethod == null)            throw parseError(BADNEWOBJECT);          if (target==null) { // last chance, might be a static....            if ( Modifier.isStatic( theMethod.getModifiers() )  )              target = theClass;            else              throw parseError("Non-static method of uninstantiated class");          }          dec.target = theMethod.invoke(target, realargs);          dec.type = CorlDeclare.CORL_OBJECT;          if ( (token = stok.nextToken()) != ';')            throw parseError(BADNEWOBJECT);          return;        }      } catch (IOException e) {}      throw parseError(BADNEWOBJECT);    }    private void isDeclaration(String firstWord, StreamTokenizer stok, String theLabel)                      throws ParameterFileFormatException    {      String classname = new String(firstWord);      Class newbieClass = lookupClass(classname);      if (newbieClass == null)        throw parseError(CLASSNOTFOUND);      try {        int token;        CorlDeclare theDeclare;        while (true) {          if (stok.ttype != stok.TT_WORD)            throw parseError("Missing word in declaration ");          String newId = new String(stok.sval);          buildingBlock.context.classes.addElement(            theDeclare = new CorlDeclare(newId, newbieClass, CorlDeclare.CORL_CLASS)          );          if ( (token = stok.nextToken()) == stok.TT_WORD)            break;          else if (token == ';')            return;          else if (token == '=') {            // ah, we're initializing--not just a class, but an object            try {              setObject(theDeclare, stok);              return;            } catch (Exception e) {              throw parseError(e.getMessage());            }          } else if (token == ',') {            if ( (token = stok.nextToken()) != stok.TT_WORD)              break;            continue;          }        }      } catch (IOException e) { }      throw parseError(" ");    }    // isLabel forwards stok to the next word or the word after :    private String isLabel(StreamTokenizer stok)      throws ParameterFileFormatException    {      String firstWord = new String(stok.sval);      try {        int token = stok.nextToken();        if (token != ':')          return null;        else          stok.nextToken();      } catch (IOException e) {throw parseError(" ");}      return firstWord;    }    /** if this is a statement, turn it into a param */    private Param isStatement(String firstWord, StreamTokenizer stok,                              ParamList whereToAdd, String theLabel)                      throws ParameterFileFormatException    {      Param newbie;      String classMethod = new String(firstWord);      String classname, methodname;      // stok should be "declaredClass.method" if it's a statement      // careful, javaParam("name", "value") is special case....      boolean javaParamFlag  = (isParamType(classMethod) == JAVAPARAM);      boolean insertListFlag = (isParamType(classMethod) == INSERTLIST);      boolean immediateFlag  = (isParamType(classMethod) == IMMEDIATEPARAM);      Class newbieClass      = null;      Object newbieOwner     = null;      Method[] allMethods    = null;      Vector possibleMethods = null;      final String immediateSyntax = "Expected 'immediate(statement);' ";      // immediate(blah.blah());      if (immediateFlag) {        try {          int token;          if ( ( token = stok.nextToken() ) != stok.TT_WORD)            throw parseError(immediateSyntax);          classMethod = new String(stok.sval);          token = stok.nextToken();        } catch (Exception e) {          throw parseError(immediateSyntax);        }      }      if (!(javaParamFlag || insertListFlag)) {        classname = classPart(classMethod);        if (classname == null) {          return null;        }        methodname = classMethod.substring(classname.length() + 1, classMethod.length());        // is this a declared class in buildingBlock?        CorlDeclare dec = buildingBlock.context.getDec(                      classname, buildingBlock.context.classes);        if (dec != null)          newbieClass = (Class) dec.value;        if (newbieClass == null)          return null;        // there will only be one of these in exceptional cases:        // CWA, or an object created via the paramfile. Else null.        newbieOwner = dec.target;        // is/are such-named method(s) available?        allMethods = newbieClass.getMethods();        possibleMethods = new Vector(2,2);        for (int j=0; j < allMethods.length; j++) {          if ( allMethods[j].getName().equals(methodname) ) {            possibleMethods.addElement(allMethods[j]);          }        }        if (possibleMethods.size() == 0) {          throw parseError("No such method.");        }      } // if !javaParamFlag || insertListFlag      // OK, let's read the arguments: (arg1, ...)      Vector args = readArgList(stok);      // if it is a javaParam, need precisely 2 strings as args      // if an insertList, need precisely 1 string      Param p;      if (javaParamFlag) {        if (args.size() != 2)          throw parseError(EXPECTEDJAVAPARAM);        Object o;        for (int k=0;k<2;k++) {          o = args.elementAt(k);          if (o.getClass() != String.class)            throw parseError(EXPECTEDJAVAPARAM);        }        // and make a Param...        p = new Param((String) args.elementAt(0), args.elementAt(1), null, null, false);      // insert list...      } else if (insertListFlag) {        if (args.size() != 1)          throw parseError(EXPECTEDINSERTLIST);        Object o = args.elementAt(0);        if (o.getClass() != String.class)          throw parseError(EXPECTEDINSERTLIST);        String paramBlockName = (String) o;        // and insert the list...        ParamBlock blockToAdd = ParamBlock.findInVector(blocks, paramBlockName);        p = buildingBlock.copyIn(blockToAdd);      // it's a statement--find its details      } else {        Method method = findMethod(possibleMethods, args);        if (method == null)          throw parseError(METHODNOTFOUND);        // and make a Param...        p = new Param("", properValues, newbieClass, method, false);        p.owner=newbieOwner;      }      // immediate( statement ) , name... Name is pointless.      if (immediateFlag) {        getNeeded(')', stok);      }      // check for name of parameter      if (getNeeded(',', stok)) {        try {          int token;          if ((token = stok.nextToken()) == '"') {            if (javaParamFlag || insertListFlag)              throw parseError(PARAMNAMENOTALLOWED);            String paramname = new String(stok.sval);            p.name = paramname;            p.displayable=true;          } else {            throw parseError(EXPECTED + "\"string\"");          }        } catch (Exception e) {            throw parseError(" ");        }      }      if (!getNeeded(';', stok))        throw parseError(EXPECTED + ";");      if (immediateFlag) {        try {          p.apply();        } catch (Exception e) {          throw parseError("Immediate execution failed");        }        return p;      }      if ( !insertListFlag  )  // already added?        whereToAdd.add(p);      if (theLabel != null)         buildingBlock.addLabel(theLabel, p, whereToAdd);      // bind (only) CWA object      if (p.ownerClass == CWAClass) {          p.owner=CWA;      }      return p;    }    private  Object[] properValues; // shared by findMethod & isStatement    // if method found, the argList is type-converted to match    private Method findMethod(Vector possibleMethods, Vector args)      throws ParameterFileFormatException    {      Method m;      Class[] types;      sortIntsForward(possibleMethods);      for (int j=0; j < possibleMethods.size(); j++) {        m = (Method) possibleMethods.elementAt(j);        types = m.getParameterTypes();        if ( ( properValues = signatureMatches(types, args) ) != null) {          return m;        }      }      return null;    }    /** true if a contains more ints than b */    private boolean moreIntsThan(Class[] a, Class[] b) {      int counta = 0;      int countb = 0;      int i;      for (i=0; i<a.length; i++)        if (a[i] == int.class)          counta++;      for (i=0; i<b.length; i++)        if (b[i] == int.class)          countb++;      return counta > countb;    }    /** reorder array so constructors with most int args appear first.     *  Nuisance--until Java1.2, Constructor and Method have no common     *  superclass.     */    private void sortIntsForward(Constructor[] cons) {      // bubblesort      Constructor temp;      for (int i=0; i<cons.length-1; i++) {        for (int j=i+1; j<cons.length; j++) {          if ( moreIntsThan(cons[j].getParameterTypes(), cons[i].getParameterTypes()) ) {            temp    = cons[i];            cons[i] = cons[j];            cons[j] = temp;          }        }      }    }    /** reorder vector so methods with most int args appear first. */    private void sortIntsForward(Vector methods) {      // bubblesort      Method a, b;      for (int i=0; i<methods.size()-1; i++) {        for (int j=i+1; j<methods.size(); j++) {          a = (Method) methods.elementAt(i);          b = (Method) methods.elementAt(j);          if ( moreIntsThan( b.getParameterTypes(), a.getParameterTypes() ) ) {            methods.setElementAt(b, i);            methods.setElementAt(a, j);          }        }      }    }    /** Warning: Ginger: there is no way short of subclassing StreamTokenizer     *  to get parsing a long to work if it needs the whole precision.     *  991008: problem--JRE 1.2.2 fails our scheme often (maybe old JRE     *  would have, too, with diff classes used) if (float, float, float)     *  shows up before (int, int, int) and could be either, picks the floats.     *  to get around this, we need to sort the candidates -before- applying     *  sigMatches.     */    private Object[] signatureMatches(Class[] types, Vector vals)                      throws ParameterFileFormatException    {        int valcount = vals.size();        int methodcount = types.length;        Object[] answer = new Object[valcount];        if (valcount != methodcount)            return null;        // remember, our vals are String, Double, null, or <something>.        for (int i=0; i < valcount; i++) {            Object thisval = vals.elementAt(i);            if ( ( !types[i].isPrimitive() ) &&                 ( thisval == null ) ) {                  answer[i] = null;            } else if ( ( types[i].isPrimitive() ) &&                 ( thisval instanceof Double ) ) {                try {                    Double num = (Double) thisval;                    if (types[i] == int.class)                        answer[i] = new Integer(num.intValue());                    if (types[i] == boolean.class)                        answer[i] = new Boolean( ( num.intValue() == 1) );                    else if (types[i] == byte.class)                        answer[i] = new Byte(num.byteValue());                    else if (types[i] == double.class)                        answer[i] = num;                    else if (types[i] == float.class)                        answer[i] = new Float(num.floatValue());                    else if (types[i] == long.class)                        answer[i] = new Long(Double.doubleToLongBits(num.doubleValue()));                    else if (types[i] == short.class)                        answer[i] = new Short(num.shortValue());                } catch (Exception e) {                    return null;                }             } else if ( (types[i] == String.class) &&                         (thisval instanceof String) ) {                answer[i] = new String( (String) thisval );             } else if ( (types[i] == boolean.class) &&                         (thisval instanceof Boolean) ) {                answer[i] = thisval;             } else if ( (types[i] == int.class) &&                         (thisval instanceof Boolean) ) {                if ( ((Boolean) thisval).booleanValue() )                  answer[i] = new Integer(1);                else                  answer[i] = new Integer(0);             } else if ( types[i].isInstance(thisval) ) {                answer[i] = thisval;             } else {                return null;             }        }        return answer;     }    // Only good for ParamList, with no-arg method requirement.    private void setClassAndMethod(ParamList p, String s)      throws ParameterFileFormatException    {      String classname = classPart(s);      int splitsOn = classname.length();      if (splitsOn <= 0)        throw parseError("Malformed class.method expression.");      Class c = lookupClass(s.substring(0, splitsOn));      if (c == null) throw parseError(CLASSNOTFOUND);      p.ownerClass=c;      Class[] noArgs = new Class[] {};      try {        Method m = c.getMethod(s.substring(splitsOn+1, s.length()), noArgs);        p.method=m;      } catch (Exception e) {        throw parseError(METHODNOTFOUND);      }    }    private int isParamType(String s) {        if (strEquals(s, javaParamKeyword) )          return JAVAPARAM;        if (strEquals(s, insertListKeyword) )          return INSERTLIST;        if (strEquals(s, immediateKeyword) )          return IMMEDIATEPARAM;        return NORMALPARAM;    }    private ParameterFileFormatException parseError(String msg)    {      if (verboseFlag) {        System.out.println("\n\nParamVerbose dump on error:");        masterListDump();      }      if (stok == null)        return new ParameterFileFormatException(msg +              ", no file, in ParamMgr.parse(" + saveURL + ")");      return new ParameterFileFormatException (                      msg +                      " - line " + stok.lineno() +                      " in ParamMgr.parse(" + saveURL + ")");    }    private Vector readArgList(StreamTokenizer stok)            throws ParameterFileFormatException    {      if (stok.ttype != '(')        throw parseError(EXPECTED + "(");      Vector argList = new Vector(2,2); // one empty argList, valid return value      int token; // one of stok's constants      try {        while ((token = stok.nextToken()) != stok.TT_EOF) {          switch (token) {            case StreamTokenizer.TT_WORD:              // a few wordy constructs are permissable: true, false, maybe new              // also references to gizmos new'd in this paramfile.              if (stokEquals(trueKeyword)) {                argList.addElement(new Boolean(true));              } else if (stokEquals(falseKeyword)) {                argList.addElement(new Boolean(false));              } else if (stokEquals(nullKeyword)) {                argList.addElement(null);              } else {                // otherwise, if it ain't declared, this ain't valid                CorlDeclare dec = buildingBlock.context.getDec(stok.sval,                              buildingBlock.context.classes);                Object what = null;                if (dec != null)                  what = dec.target;                if (what == null)                  throw parseError(CLASSNOTFOUND + stok.sval);                argList.addElement(what);              }              break;            case StreamTokenizer.TT_NUMBER:              argList.addElement(new Double(stok.nval));              break;            case '"':              argList.addElement(new String(stok.sval));              break;            case ')':              return argList;            default :              throw parseError(EXPECTED + "(");          } /* switch */          if (getNeeded(',', stok))            continue;          else if (getNeeded(')', stok))            return argList;          else            throw parseError(EXPECTED + ")");        }      } catch (IOException e) {          throw parseError(EXPECTED + "(args)");      }      return argList;    }    private void readParam(ParamList whereToAdd)                 throws ParameterFileFormatException    {        ParamList currentList    = whereToAdd;        Param currentParam       = null;        boolean topBlockOpened   = false;  // this recurse opened a top block        int token; // one of stok's constants        try {            readloop:            while ((token = stok.nextToken()) != stok.TT_EOF) {  		        switch (token) {		            case StreamTokenizer.TT_WORD:                  if (isDirective(stok))                    continue readloop;                  // save this because isLabel consumes                  String saveWord = new String(stok.sval);                  String label = isLabel(stok);                  if (label != null) {                    saveWord = new String(stok.sval);                    stok.nextToken();                  }                  if (isInsertFile(saveWord, stok,label))                    continue readloop;                  // is it list beginning?                  ParamList tempList = isGlobalList(saveWord, stok, label);                  if (tempList == null)                    tempList = isScenarioList(saveWord, stok, label);                  if ((tempList != null) && (!topBlockOpened))                    topBlockOpened = true;                  if (tempList == null)                    tempList = isParamList(saveWord, stok, currentList, label);                  // check if ParamList opened a freefloating ParamBlock                  if ( !topBlockOpened && (statusInWhat == STATUS_INBLOCKPARAMS) )                    topBlockOpened = true;                  if (tempList != null) {                    readParam(tempList);                    continue readloop;                  }                  // is it a statement?                  currentParam = isStatement(saveWord, stok, currentList, label);                  if (currentParam != null)                    continue readloop;                  // isDeclaration requires it to be a declaration.                  isDeclaration(saveWord, stok, label);                  continue readloop;                case '}':                  if (topBlockOpened)                    statusInWhat = STATUS_OUTOFBLOCK;                  return;                }                continue readloop;              }        } catch (IOException e) {            System.err.println(e);            throw parseError(" ");        }        if (topBlockOpened)          statusInWhat = STATUS_OUTOFBLOCK;        return;     }     // return prefix up to last "." in concatenated name     private String classPart(String concatenated) {        String className = "";        // . is a token        StringTokenizer chopper = new StringTokenizer(concatenated, ".", true);        int tokenCount = chopper.countTokens();        // tokens will come in odd numbers here: A or A.B or A.B.C , etc.        if (tokenCount == 1)            return null;        for (int i=0; i<tokenCount - 2; i++)            className += chopper.nextToken();        return className;     }     private Class lookupClass(String name) {        Class tester = null;        CorlDeclare dec = buildingBlock.context.getDec(name,                         buildingBlock.context.classes);        if (dec != null)          tester = (Class) dec.value;        if (tester != null)          return tester;        if (hashFound.containsKey(name))          return (Class) hashFound.get(name);        if (hashNotFound.containsKey(name))          return null;        try {          tester = Class.forName(name);        } catch (Exception e) {          tester = null;        }        if (tester == null)          hashNotFound.put(name, ""); // gets ill if pass a null value        else          hashFound.put(name, tester);        return tester;     }}/* ParamMgr */  // The following cannot be inner classes of ParamMgr because then they're  // not allowed to have static members, which is inconvenient. // class or label declaration = CorlDeclare  class CorlDeclare {    String name;    Object value;  // a label's value is the Param that was labeled, else class    Object target; // if CORL_OBJECT, has class and object target    int type;    static final int CORL_CLASS  = 0;    static final int CORL_LABEL  = 1;    static final int CORL_OBJECT = 2;    public CorlDeclare(String label, Object arbValue, int arbType) {      name  = label;      value = arbValue;      type  = arbType;      if (arbValue instanceof Class) {      // special handling for declarations of cwa        if ( ((Class)arbValue).isAssignableFrom( ParamMgr.CWAClass) ) {          type = CORL_OBJECT;          target = ParamMgr.CWA;        }      }    }    public CorlDeclare(String label, Object arbValue, int arbType, Object target) {      name  = label;      value = arbValue;      type  = arbType;      this.target = target;    }    public String toString() {      return "CorlDeclare[name=" + name + ",type=" + type +",value=" + value + ",target=" + target + "]";    } } // Declaration context, basically a Vector with behaviors class BlockContext {    Vector classes;    Vector labels;    public BlockContext(BlockContext master) {      classes = new Vector();      labels = new Vector();      if (master != null) this.copyIn(master, false);    }    private void copyIn(Vector which, Vector from) {      CorlDeclare cd;      for (int i=0; i<from.size(); i++) {        cd = (CorlDeclare) from.elementAt(i);        which.addElement(new CorlDeclare(cd.name, cd.value, cd.type, cd.target));      }    }    public void copyIn(BlockContext moreContext, boolean decsOnly) {      copyIn(classes, moreContext.classes);      if (!decsOnly)        copyIn(labels, moreContext.labels);    }    static public CorlDeclare getDec(String label, Vector whichList) {      CorlDeclare any = null;      for (int i=0;i<whichList.size(); i++) {        any = (CorlDeclare) whichList.elementAt(i);        if ( any.name.equals(label) )          return any;      }      return null;    }    public String getLabel(Param p) {      CorlDeclare any;      for (int i=0; i<labels.size(); i++) {        any = (CorlDeclare) labels.elementAt(i);        Object anyo = any.value;        if ((anyo instanceof ParamList) && (p instanceof ParamList)) {          if (((ParamList)(anyo)).equals((ParamList)p)) {            return any.name;          }        } else if ( ((Param)(anyo)).equals(p)) {          return any.name;        }      }      return null;    } } // a ParamBlock is simply ParamList + its BlockContext class ParamBlock {    ParamList params;    BlockContext context;    // copy globals in    public ParamBlock(String name, ParamBlock globals,        boolean includeParamList, boolean includeGlobals)      throws ParameterFileFormatException    {      if (includeGlobals)        context = new BlockContext(globals.context);      else        context = new BlockContext(null);      // probably Scenario      if (includeParamList) {        params = (ParamList) globals.params.cloneRecursive();        params.name = name;      // probably free-floating ParamList      } else {        params = new ParamList(name);        context.labels = new Vector();      }    }    // returns first new Param of the list that was copied in (list top omitted)    public Param copyIn(ParamBlock includeBlock)      throws ParameterFileFormatException    {      ParamList newparams = (ParamList) includeBlock.params.cloneRecursive();      Param firstAdded = null;      // copy in declarations      context.copyIn(includeBlock.context, true);      // want to include not the cloned list top, but its members      Param p;      if (newparams.size() == 0)        return null; // empty list...      for (int i=0; i<newparams.size(); i++) {        p = (Param) newparams.getElement(i);        params.add(p);        if (firstAdded == null)          firstAdded = p;        String label = includeBlock.context.getLabel(p);        if (label != null)          addLabel(label, p, params);        if (p instanceof ParamList)          checkLabelsBelow((ParamList) p, includeBlock.context);      }      return firstAdded;    }    private void checkLabelsBelow(ParamList pl, BlockContext origContext)      throws ParameterFileFormatException    {      Param p;      String label;      for (int i=0; i<pl.size(); i++) {        p = (Param) pl.getElement(i);        label = origContext.getLabel(p);        if (label != null)          addLabel(label, p, params);        if (p instanceof ParamList)          checkLabelsBelow((ParamList) p, origContext);      }    }    // if no label already in context, just add one. Else replace prior and    // remove from currentList. In other words, adding the labeled statement    // also resolves the labeled statement.    public void addLabel(String label, Param param, ParamList currentList)      throws ParameterFileFormatException    {      CorlDeclare dec =  context.getDec(label, context.labels);      Param prior = null;      if (dec != null)        prior = (Param) dec.value;      if (prior == null) {        context.labels.addElement(new CorlDeclare(label,param, CorlDeclare.CORL_LABEL));      } else {        ParamList listForPrior = (ParamList) params.find(prior, false, true);        if (listForPrior == null)          throw new ParameterFileFormatException("Labelling screwup");        // find prior statement in its list and replace it        // we're having real difficulty reaching the right equals routine...        Param ap;        ParamList apl;        int start = -1; // 0 or more if found something to replace        priors:        for (int i=0; i<listForPrior.size(); i++) {          if ((listForPrior.getElement(i) instanceof ParamList)               && (prior instanceof ParamList)) {            apl = (ParamList) listForPrior.getElement(i);            if (apl.equals((ParamList)prior)) {              listForPrior.setElement(i, param);              start = (listForPrior == currentList) ? i+1 : 0;            }          } else if (listForPrior.getElement(i).equals(prior)) {            listForPrior.setElement(i, param);            start = (listForPrior == currentList) ? i+1 : 0;          }          if (start >= 0) {            // find this statement in current list and remove it            for (int j=start; j<currentList.size(); j++) {              if (currentList.getElement(j).equals(param)) {                currentList.removeElement(j);                break priors;              }            }            break priors;          }        }      }    }    public static ParamBlock findInVector(Vector v, String name) {      ParamBlock any;      for (int i=0; i<v.size(); i++) {        any = (ParamBlock) v.elementAt(i);        if (any.params.name.equals(name))          return any;      }      return null;    } }