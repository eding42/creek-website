/* * * @(#)TableLayout.java 0.1 97/09/23 * * Copyright (c) 1997 Ginger Booth.  All Rights Reserved. * * @history: original * @author Ginger Booth * @version 0.1,  September 1997 */package courseware.util;import java.awt.* ;import java.util.* ;/** Note to self:  remember when setting up a Frame, let pack() call layout, *  and then call show().  I.e., don't call layout() on a Frame, just *  pack() and show(). */public class TableLayout implements LayoutManager2 {    static public final String RIGHT = "RIGHT";    static public final String BELOW = "BELOW";    static public final String NEXT  = "NEXT"; // no opinion     private Dimension prefsize;    private Vector rows = new Vector(5,5);    private int maxcol  = -1;    private int maxrow  = -1;    private int spacex  = 0;	// apply around and between.    private int spacey  = 0;    private Label nullLabel;	// table apparently balks at holes    /** Note that a TableLayout is later set to exactly the size it is.     *  This is for popup menus built on the fly.     */    public TableLayout(int padx, int pady) {        prefsize  = new Dimension(0,0);        spacex    = padx;        spacey    = pady;        nullLabel = new Label();    }    public TableLayout() { this(0,0); }    public Label getNullLabel() { return nullLabel; }    public void addLayoutComponent(String name, Component comp) {      int mycol, myrow;      if (name.equals(RIGHT)) {        if (maxrow >= 0){          myrow = maxrow;          mycol = ( (Vector) rows.elementAt(myrow)).size();        } else {          myrow = 0;          mycol = 0;        }      } else {        myrow = maxrow + 1;        mycol = 0;      }      setConstraint(comp, myrow, mycol);    }    public void addLayoutComponent(TableLayoutConstraint constraint, Component comp) {      setConstraint(comp, constraint.row, constraint.col);    }    public void removeLayoutComponent(Component comp) {    	int i;    	Enumeration e = rows.elements();    	Vector row;    	while (e.hasMoreElements()) {    	    row = (Vector) e.nextElement();    	    i   = row.indexOf( comp );            if (i >= 0)	            row.removeElementAt( i );    	}    }    /** Hopefully, this frees all components to be garbage-collected. */    public void removeAllComponents() {    	int i;    	Enumeration e = rows.elements();    	Vector row;    	while (e.hasMoreElements()) {    	    row = (Vector) e.nextElement();    	    row.removeAllElements();    	}    	rows.removeAllElements();        maxcol = -1;        maxrow = -1;    }    public Dimension minimumLayoutSize(Container target) {	    return prefsize;    }    public Dimension preferredLayoutSize(Container target) {	    return prefsize;    }    /** Only does something if component has been added but not assigned     *  into the rows yet. Note that row and col are zero-base. I.e., upper     *  left corner = row 0, col 0.     */    public void setConstraint(Component c, int row, int col)    {    	if (row >= rows.size()) {    	    for (int j=0; j <= row; j++) {    	        rows.addElement(new Vector(5,5));    	    }    	}        Vector thisrow = (Vector) rows.elementAt(row);        thisrow.ensureCapacity(col+1);        for (int i=thisrow.size(); i <= col; i++)            thisrow.addElement(nullLabel);        thisrow.setElementAt(c, col);        if (row > maxrow)            maxrow = row;        if (col > maxcol)            maxcol = col;    }    public int getLastRow() {return maxrow;}    public int getLastCol() {return maxcol;}    /** if none in row, returns -1 */    public int getLastColInRow(int i) {        if (i > maxrow) return -1;        if (i < 0) return -1;        return ((Vector) rows.elementAt(i)).size() - 1;    }    public Vector getRow(int i) {        if (i > maxrow) return null;        if (i < 0) return null;        return (Vector) rows.elementAt(i);    }    public void layoutContainer(Container target) {        if ((maxrow < 0) || (maxcol < 0))          return;        Vector row;        prefsize.width  = 0;        prefsize.height = 0;        Insets insets   = target.getInsets();        int i, j;        int colWidth[]  = new int[maxcol+1];        int colOrigin[] = new int[maxcol+1];        int rowHeight[] = new int[maxrow+1];        int rowOrigin[] = new int[maxrow+1];        Rectangle bounds;        Component component;        Dimension d;        for (i=0; i <= maxrow; i++) {            row = (Vector) rows.elementAt(i);            row.ensureCapacity(maxcol+1);            for (j=0; j < row.size(); j++) {                component = (Component) row.elementAt(j);                if (component != null) {                    d = component.getPreferredSize();                    if (d.width > colWidth[j])                        colWidth[j] = d.width;                    if (d.height > rowHeight[i])                        rowHeight[i] = d.height;                }            }        }        // Calc origins for rows/cols, space applied around and between.        rowOrigin[0] = insets.top + spacey;        for (i=1; i <= maxrow; i++) {            rowOrigin[i]  = rowOrigin[i-1] + rowHeight[i-1] + spacey;        }        colOrigin[0]  = insets.left + spacex;        for (j=1; j <= maxcol; j++) {            colOrigin[j] = colOrigin[j-1] + colWidth[j-1] + spacex;        }        // overall size        prefsize.width  = colOrigin[maxcol] + colWidth[maxcol]  + spacex;        prefsize.height = rowOrigin[maxrow] + rowHeight[maxrow] + spacey;        prefsize.width  += insets.left;        prefsize.height += insets.bottom;        for (i=0; i <= maxrow; i++) {            row = (Vector) rows.elementAt(i);            for (j=0; j < row.size(); j++) {                component = (Component) row.elementAt(j);                // vfb, 000225, added component set/unset visible in an attempt                // to make buttons/popups appear correctly under Linux Netscape                component.setVisible(false);                if (component != null) {                    component.setBounds(colOrigin[j], rowOrigin[i],                                      colWidth[j],  rowHeight[i]);                }                component.setVisible(true);            }        }        target.setSize(prefsize.width, prefsize.height);    }    public void setPaddingX(int pad) { spacex = pad; }    public void setPaddingY(int pad) { spacey = pad; }    public int getPaddingX() { return spacex; }    public int getPaddingY() { return spacey; }    /** vfb, 000222, adding LayoutManger2 support in attempt to get Mac working.*/    /**     * Invalidate the layout, indicating that if the layout manager     * has cached information it should be discarded. Taken verbatim     * from BorderLayout. Does nothing.     */    public void invalidateLayout(Container target) {    }    /** LayoutManager2 interface, JDK1.1. */    public float getLayoutAlignmentX(Container parent) {	    return 0.5f;    }    public float getLayoutAlignmentY(Container parent) {	    return 0.5f;    }    public Dimension maximumLayoutSize(Container target) {	    return new Dimension(Integer.MAX_VALUE, Integer.MAX_VALUE);    }    /** Is required by interface, JDK1.1. Adds to slice 1. */    public void addLayoutComponent(Component comp, Object constraints) {      if ((constraints == null) || (constraints instanceof String)) {          addLayoutComponent((String)constraints, comp);      } else if (constraints instanceof TableLayoutConstraint) {          addLayoutComponent((TableLayoutConstraint)constraints, comp);      } else {          throw new IllegalArgumentException("cannot add to layout: constraint must be a string (or null)");      }    }} /* TableLayout */