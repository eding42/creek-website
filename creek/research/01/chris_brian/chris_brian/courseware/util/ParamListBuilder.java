/* * * @(#)ParamListBuilder.java 0.3 990901 * * Copyright (c) 1997-1999 Ginger Booth.  All Rights Reserved. * * @history: 990901, original experiment--autogenerate popup *           for species parameters for Gecko. * @author Ginger Booth * @version 0.3, September 1999 */package courseware.util;import java.beans.*;import java.lang.reflect.*;import java.util.Vector;/** This class's static method listFor, finds the beanish properties *  of a class supported by the Param engine, and returns a ParamList *  suitable for putting on a popup menu for editing. Note that the *  values in the ParamList are the -current- values of those params. *  I.e., although the ParamList returned refers only to the set methods *  of the properties, the get methods of those properties are called *  here to get the initial values of the Param's on the ParamList. */public class ParamListBuilder {  /** stopclass is where to stop going down the hierarchy. "null" is   *  fine, and allows the Inspector engine to figure out what's good   *  for you. In Gecko case, agent stopclass is Quad.   *   *  PROBLEM:  This routine works fine, in application mode. But in   *  Netscape, "Introspector.getBeanInfo" throws a security violation.   *  So, can't use for applets.   */  public static ParamList listFor(Object bean, Class stopclass) {    ParamList answer = new ParamList();    try {      BeanInfo beaninfo = Introspector.getBeanInfo(bean.getClass(), stopclass);      if (beaninfo == null)        return null;      PropertyDescriptor[] props = beaninfo.getPropertyDescriptors();      if (props != null) {        for (int i=0; i<props.length; i++) {          PropertyDescriptor pd = props[i];          String name = pd.getDisplayName();          if (name == null) name = "null";          Method getm = pd.getReadMethod();          Method setm = pd.getWriteMethod();          if ((getm != null) && (setm != null)) {            if ( !Modifier.isPublic(setm.getModifiers()) )              continue;           Class[] ptypes = setm.getParameterTypes();            boolean allBasic = true;            for (int j=0;j<ptypes.length; j++) {              if ( !Param.isBasicType(ptypes[j]) )                allBasic = false;            }            Param p;            try {              if (allBasic) {                if (ptypes.length > 1) {                  Object[] val = new Object[ptypes.length];                  for (int j=0; j<ptypes.length; j++) {                    val[j] = getm.invoke(bean, Param.NO_ARGS);                  }                  p = new Param(pd.getDisplayName(), val, bean, setm, true);                } else {                  Object val = getm.invoke(bean, Param.NO_ARGS);                  p = new Param(pd.getDisplayName(), val, bean.getClass(), setm, true);                  p.setOwner(bean);                }                answer.add(p);              }            } catch (Exception e2) {              System.err.println("Error building param list, property " + pd.getDisplayName());              e2.printStackTrace();            }          }        }      }    } catch (IntrospectionException e) {      e.printStackTrace();    }    return answer;  }  /** This routine takes a array of property names and returns an   *  array of PropertyDescriptors for those names for this object.   *   *  Retures however many properties it succeeded at, if not all. Maybe none.   *  So don't assume the answer array has as many elements as the argument array.   *   *  Property names begin with a lowercase letter.   */  public static PropertyDescriptor[] propertiesFor(Object bean, String[] propertyNames) {    Vector answer = new Vector(0,1);    PropertyDescriptor prop;    for (int i=0; i<propertyNames.length; i++) {      try {        prop = new PropertyDescriptor(propertyNames[i], bean.getClass());        answer.addElement(prop);      } catch (IntrospectionException e) {}    }    return vectorToArray(answer);  }  /** Note that the returned ParamList is unnamed. */  public static ParamList paramListFor(Object bean, String[] propertyNames) {    PropertyDescriptor[] props = propertiesFor(bean, propertyNames);    ParamList answer = new ParamList();    for (int i=0; i<props.length; i++) {      // just putting things in variables for convenience      String name = props[i].getDisplayName();      if (name == null) name = "null";      Method getm = props[i].getReadMethod();      Method setm = props[i].getWriteMethod();      Class[] ptypes = setm.getParameterTypes();      Param p;      try {        if (ptypes.length > 1) {          Object[] val = new Object[ptypes.length];          for (int j=0; j<ptypes.length; j++) {            val[j] = getm.invoke(bean, Param.NO_ARGS);          }          p = new Param(props[i].getDisplayName(), val, bean, setm, true);        } else {          Object val = getm.invoke(bean, Param.NO_ARGS);          p = new Param(props[i].getDisplayName(), val, bean.getClass(), setm, true);          p.setOwner(bean);        }        answer.add(p);      } catch (Exception e2) {        System.err.println("Error building param list, property " + props[i].getDisplayName());        e2.printStackTrace();      }    }    return answer;  }  public static PropertyDescriptor[] vectorToArray(Vector propertyDescriptors) {    PropertyDescriptor[] answer = new PropertyDescriptor[propertyDescriptors.size()];    for (int i=0; i<propertyDescriptors.size(); i++)      answer[i] = (PropertyDescriptor) propertyDescriptors.elementAt(i);    return answer;  }}