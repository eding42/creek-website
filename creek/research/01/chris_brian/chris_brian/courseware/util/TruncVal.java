/* * * @(#)TruncVal.java 0.2 99/03/25 * * Copyright (c) 1999 Ginger Booth.  All Rights Reserved. * * @history: 980429, in finessing for Java 1.1 port * @history: original * @author Ginger Booth * @version 0.1, August 1997 * @version 1.0+, got rid of CommentMgr, but truncVal still useful. */package courseware.util;import java.applet.*;import java.awt.*;import java.util.*;public class TruncVal {    public static int defaultDigits = 6;    /** Return the power of 10 of this value */    public static int order(double val) {      if (isException(val))        return 0;      val = Math.abs(val);      return (int) Math.floor(Math.log(val)/Math.log(10.));    }    private static boolean isException(double val) {      if ( (val == 0.0) ||           (Double.isNaN(val)) ||           (val == Double.POSITIVE_INFINITY) ||           (val == Double.NEGATIVE_INFINITY) )        return true;      else return false;    }    /** Return the mantissa of this value */    public static double mantissa(double val, int sigdigs) {      if (isException(val))        return val;      int tenExp = order(val);      double tenMult = Math.pow(10., tenExp);      double mant = val / tenMult;      int digitsAsInt = (int) Math.floor(Math.abs(mant) * Math.pow(10., sigdigs-1) + 0.5);      if (mant < 0)        digitsAsInt = - digitsAsInt;      mant = (double) digitsAsInt;      // prevent roundoff from Math using e-logs for 10-calc's....      tenMult = Math.pow(10.0, sigdigs-1);      mant /= tenMult;      return mant;    }    /** Truncate the damned things. Java doesn't do this at ALL well, roundoff propagates....     */    public static double truncVal(double val) {return truncVal(val, defaultDigits);}    public static String stringVal(double val, int sigdigs) {      int ord = order(val);      java.text.NumberFormat nf = java.text.NumberFormat.getNumberInstance();      int frac = sigdigs - (ord+1);      if (frac < 0) frac = 0;      nf.setMaximumFractionDigits(frac);      return nf.format(val);    }/*    public static double truncVal(double val, int sigdigs) {      double tens = Math.pow(10, order(val));      double answer = mantissa(val, sigdigs) * tens;System.err.println("truncVal("+val+","+sigdigs+")=" + answer );      return answer;/*      int digitsAsInt = (int) Math.floor(Math.abs(mant) * Math.pow(10., sigdigs-1) + 0.49);      StringBuffer buffy = new StringBuffer(sigdigs+2+ord);      if (ord > sigdigs - 1) {        buffy.insert(0, digitsAsInt);        if (ord >= sigdigs) {          for (int i=0; i<=(ord-sigdigs); i++)            buffy.append('0');        }      } else if (ord < 0) {        buffy.insert(0, '.');        for (i=      }      buffy.insert(0, s.substring(0, period = s.indexOf('.'));      if (mant < 0) ...      // 2.8 * 10 = 22.799999999999997 ... ARGH!!!!      // does same happen with a float 10?      float fprod = Math.round(product);      product = (double) fprod;System.err.println("truncVal("+val+","+sigdigs+")=" + product + ",mant=" + mant + ",tens=" + tens);      return product;*/    public static double truncVal(double val, int sigdigs) {        if (Double.isNaN(val) || Double.isInfinite(val))          return val;        double answer = 1;        if (val < 0)            answer = -1;        double mant = Math.abs(val);	// mantissa        int tenExp  = 0; //exponent        double tenMult; // 10 ^ tenExp        int siggyten= 1;        int siggy;        for (int i=0; i <sigdigs; i++)            siggyten *= 10;        // get mantissa and exponent        if (mant == 0) {        } else if (mant >= 1) {            while (mant > 1) {                tenExp += 1;                mant  = mant/10.0;            }        } else if (mant < .1) {            while (mant < .1) {                tenExp -= 1;                mant  = mant*10.0;            }        }        tenMult = Math.pow(10, tenExp);        // rint doesn't work, round doesn't work....        siggy  = (int) Math.floor((mant * siggyten) + .5);        answer = answer * (double) siggy * tenMult / siggyten;        return answer;    }    public static float truncVal(float val) {return truncVal(val, defaultDigits);}    public static float truncVal(float val, int sigdigs) {        double answer = val;        answer = truncVal(answer, sigdigs);        return (float) answer;    }    public static ScientificNotation getScientificNotation(double val, int maxsigdigs) {        return new ScientificNotation(mantissa(val, maxsigdigs), order(val));    }} /* end TruncVal */