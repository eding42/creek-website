/* * * @(#)Param.java 0.1 97/09/23 * * Copyright (c) 1997-1999 Ginger Booth.  All Rights Reserved. * * @history: 980422, rewrite for 0.2, Params & Java 1.1 overhaul * @history: original * @author Ginger Booth * @version 0.1, September 1997 * @version 1.0+, mar99, pruning binary. */package courseware.util;/** Generic single parameter, capable of putting itself into a popup menu for *  user to fiddle with. */import java.awt.*;import java.applet.*;import java.util.*;import java.lang.reflect.*;public class Param extends Object implements Cloneable {    public String name;    public Object[] value;   // due to arguments of Method.invoke()    public Class  ownerClass;    public Method method;    public Object owner;    public boolean displayable;    public int myRow;    private int rowsPerThisParam = 1; // may have taken more than one line    protected int myColumn;    public static int intWidth    =  3;    public static int doubleWidth =  6;    public static int stringWidth = 15;    // this is for access to status line for complaints    public static Applet applet = null;    public static final Class[] NO_ARGS_SIGNATURE = new Class[] {};    public static final Object[] NO_ARGS = new Object[] {};    /** Display flag controls whether this is     *  ommitted when asked to addToPopup.     *  SPECIAL CASE:  if this parameter is to a static method of a     *  class, there may be no owner for purposes of Method.invoke.     *     *  All arguments (values) must be cloneable, except for the base     *  types.  Be especially careful subclassing Param, for since it     *  provides a clone(), your subclass defaults to Param's clone,     *  minus everything the subclass adds.     */    public Param(String label, Object[] val, Class oclass, Method classMethod,                 boolean display)    {        value       = val;        name        = label;        owner       = null;        ownerClass  = oclass;        displayable = display;        method      = classMethod;    }    public Param(String label, Object val, Class oclass, Method classMethod,                 boolean display)    {        value       = new Object[] {val};        name        = label;        owner       = null;        ownerClass  = oclass;        displayable = display;        method      = classMethod;    }    public Param(String label, Object[] val, Object atarget,                 Method classMethod, boolean display)    {        value       = val;        name        = label;        if (atarget != null)            ownerClass  = atarget.getClass();        owner       = atarget;        displayable = display;        method      = classMethod;    }    /** One null Param--empty. */    public Param() {}    /** I imagine I'll have use for this again--I don't care which     *  basic type it is, just copy it.  Returns null if not basic.     */    static public Object cloneBasicType(Object o) {        if (o == null)          return null;        Class oclass = o.getClass();        Object newo = null;        if      (oclass == String.class)            newo = new String((String)o);        else if (oclass == Byte.class)            newo = new Byte(((Byte)o).byteValue());        else if (oclass == Long.class)            newo = new Long(((Long)o).longValue());        else if (oclass == Short.class)            newo = new Short(((Short)o).shortValue());        else if (oclass == Integer.class)            newo = new Integer(((Integer)o).intValue());        else if (oclass == Float.class)            newo = new Float(((Float)o).floatValue());        else if (oclass == Double.class) {            newo = new Double(((Double)o).doubleValue());        } else if (oclass == Boolean.class)            newo = new Boolean(((Boolean)o).booleanValue());        return newo;     }    /** returns true for null--null doesn't mean it's NOT basic... */    static public boolean isBasicType(Class c) {      if (c == null) return true;      if (c.isPrimitive()) return true;      if (c == String.class) return true;      if (c == Boolean.class) return true;      if (c == Number.class) return true;      return false;    }    public Object clone() {        Object newbie = null;        try {            newbie = super.clone();        } catch (Exception e) { }        Param newp = (Param) newbie;        if (value != null) {            newp.value = new Object[value.length];            for (int i=0; i<value.length; i++) {                newp.value[i] = cloneBasicType(value[i]);                // give up easy here--if nonbasic, it's not cloned.                if (newp.value[i] == null)                   newp.value[i] = value[i];            }        }       return newp;    }    public boolean equals(Param other) {      boolean answer = true;      answer = answer && (this.getClass() == other.getClass());      if (name != null)        answer = answer && (name.equals(other.name));      if (value == null)        answer = answer && (other.value==null);      else {        answer = answer && (value.length == other.value.length);        for (int i=0; i<value.length; i++) {            answer = answer && ( value[i].equals(other.value[i]) );        }      }      answer = answer && (owner == other.owner);      answer = answer && (ownerClass == other.ownerClass);      answer = answer && (method == other.method);      return answer;    }    public void erase() {        value = null;        name = null;        owner = null;        ownerClass = null;        displayable = false;        method = null;    }    /*    public int getPopupRow() {return myRow;}    public int getPopupColumn() {return myColumn;}    public boolean getVisible() {return displayable;}    public static void setApplet(Applet context) {applet = context;}*/    public void setVisible(boolean b) {displayable = b;}    public String getName() {return name;}    public void setName(String s) {name = s;}    public void setOwner(Object o) {owner = o; ownerClass = o.getClass();}    public void setOwnerClass(Class c) {ownerClass = c;}    public Object getValue() {return value;}    public Object getValue(int i) {return value[i];}    public void setValue(Object o) {value = new Object[] { o };}    public void setValue(Object[] o) {value = o;}    /** Return list of components needed for a line of popup to set this     *  "parameter".  Never called if !displayable, but should return void,     *  anyway if this is always-so.  Handle all basic types. Put something     *  ugly up on menu if called with nonbasic value.     */    public Vector components() {        return components(0);    }    /** Return list of components needed for a line of popup to set this     *  "parameter".  Start at valIndex into the value array.     */    protected Vector components(int valIndex) {        if (!displayable) {            return null;        }        Vector comps = new Vector(2,2);        Label el = new Label(name);        comps.addElement(el);        TextField t;        int width;        String s;        // We shouldn't have been called with a complex Param...        // but can't check here, because want to use it this routine        // for lists of values....        // Deal with first one of all basic types        Object o = value[valIndex];        s = o.toString();        Class oclass = o.getClass();        if (oclass == Boolean.class) {            comps.addElement(                new Checkbox("", ((Boolean) o).booleanValue()));            return comps;        } else {            comps.addElement( Param.valComponent( value[valIndex] ) );        }        return comps;    }    /** This STATIC routine makes an entry TextField for any     *  of the base classes that show up on a popup as a     *  TextField--all except Boolean and Void. Any unconvertible     *  object shows up as a TextField with bogus value.     */    static public TextField valComponent(Object o) {        int width;        String s = o.toString();        Class oclass = o.getClass();        if (oclass == String.class)            width = stringWidth;        else if ((oclass==Byte.class) || (oclass==Long.class) ||                 (oclass==Short.class) || (oclass==Integer.class) ) {            width = intWidth;        } else if ((oclass==Float.class) || (oclass==Double.class) ) {            width = doubleWidth;        } else {            s = "<" + o.getClass() + ">";            width = s.length();        }        return new TextField(s, width);    }        static public Checkbox valBoolean(Boolean b) {      return new Checkbox("", b.booleanValue());    }    /** Set the value from the Vector of components.  */    public void readComponents(Vector widgets, int startcolumn) {      readComponents(0, widgets, startcolumn);    }    /** Set the value from the Vector of components.  */    protected void readComponents(int valIndex, Vector widgets, int startcolumn) {        if ( (value.length - valIndex) != 1)            return;        Component c = (Component) widgets.elementAt(startcolumn + 1);        // special case boolean--isn't a textfield        if (c instanceof Checkbox) {            value[valIndex] = new Boolean( ((Checkbox) c).getState() );            return;        }        Object test = Param.interpretTextFieldAs(              (TextField) c, value[valIndex]);        if (test != null)          value[valIndex] = test;    }    /** The STATIC reverse of valComponent. Should pass in the Object     *  that the valComponent TextField was made from. This object's     *  class is used to interpret the TextField. The decode result     *  is returned, but not stored into the argument Object o.     */    static public Object interpretTextFieldAs(TextField tf, Object o) {        String text = tf.getText();        try {            Class oclass = o.getClass();            if (oclass==String.class)                return text;            // whitespace makes it ill on numbers...least on netscape            else if (oclass==Byte.class)                return Byte.decode(text.trim());            else if (oclass==Long.class)                return Long.valueOf(text.trim());            else if (oclass==Short.class)                return Short.valueOf(text.trim());            else if (oclass==Integer.class)                return Integer.valueOf(text.trim());            else if (oclass==Float.class)                return Float.valueOf(text.trim());            else if (oclass==Double.class)                return Double.valueOf(text.trim());            else                return null;        } catch (Exception e) {            // not very effective...            System.err.println("Invalid value : " + text + " entered.");            return null;        }    }    /** Apply current value to owner. Owner==null is OK for static methods. */    public void apply() {      if (method != null) {        if (owner == null) {          if (!Modifier.isStatic(method.getModifiers()))            return;        }        try {          method.invoke(owner, value);        } catch (IllegalAccessException e) {          System.err.println("Param.apply(): " + e + ", on " + this);        } catch (InvocationTargetException e) {          System.err.println("Param.apply(): target returned " +          e.getTargetException() + ", on " + this);        }catch (NullPointerException e) {  System.err.println("Param.apply(): target returned " + e + " on " + this);}      }    }    /** target assumed to be TableLayout */    public void addToPopup(Container target, int row, int startcolumn) {        if (!displayable)            return;        TableLayout table = (TableLayout) target.getLayout();        addToPopupCommon(target, table, row, startcolumn);    }    /** target assumed to be TableLayout */    public void addToPopup(Container target, int startcolumn) {        if (!displayable) {            return;        }        TableLayout table = (TableLayout) target.getLayout();        int row = table.getLastRow();        row++;        addToPopupCommon(target, table, row, startcolumn);    }    private void addToPopupCommon(Container target, TableLayout table,                                  int row, int column)    {        myRow    = row;        myColumn = column;        int col = 0;        Vector cList = components();        Enumeration e = cList.elements();        Component c;        NewRowMarker eoln;        rowsPerThisParam = 1; // until proven otherwise...        while (e.hasMoreElements()) {            Object o = e.nextElement();            if (o instanceof Component) {              c = (Component) o;              // yes, this looks redundant, but it seems one works in some              // browsers and the other in others (Linux/Mac/IE/Netscape bulletproofing)              target.add(c, new TableLayoutConstraint(row, column + col));              table.setConstraint(c, row, column+col);              col++;            } else if (o instanceof NewRowMarker) {              eoln = (NewRowMarker) o;              row++;              col = eoln.startColumn;              rowsPerThisParam++;            }        }    }    /** What to do after popup pops down. */    public void popDown(Container target) {        TableLayout table = (TableLayout) target.getLayout();        Vector cList = getMyRowList(table, myRow);        readComponents(cList, myColumn);        cList.removeAllElements();        apply();    }    public Vector getMyRowList(TableLayout table, int row) {      Vector cList = table.getRow(row);      Component c;      Label nullLabel = table.getNullLabel();      if (rowsPerThisParam > 1) {        for (int i=1; i < rowsPerThisParam; i++) {          Vector more = table.getRow(row+i);          for (int j=0; j<more.size(); j++) {            c = (Component) more.elementAt(j);            // leave out null labels...those were inserted by indent            if (c != nullLabel)                cList.addElement(c);          }        }      }      return cList;    }    /** Same as popDown, but doesn't delete whole row of components     *  Used by ParamList.     */    protected void popDownOne(Container target) {        TableLayout table = (TableLayout) target.getLayout();        Vector cList = getMyRowList(table, myRow);        readComponents(cList, myColumn);        apply();    }    /** Now delete the components for my row--used by ParamList. */    protected void popDownClear(Container target, int row) {        TableLayout table = (TableLayout) target.getLayout();        Vector cList = getMyRowList(table, row);        cList.removeAllElements();    }    public String valueString()    {        if (value == null) return "null";        if (value.length == 0) return "empty";        String answer = "";        if (value.length > 1)          answer = "(";        answer += value[0].toString();        for (int i=1; i < value.length; i++)            answer += "," + value[i].toString();        if (value.length > 1)          answer += ")";        return answer;    }    public String toString()    {        return "Param[name=" + name +            ",value=" + valueString() +            ",displayable=" + displayable +            ",method=" + method +            "),owner=" + owner +            ",ownerClass=" + ownerClass +            "]";    }} /* Param */