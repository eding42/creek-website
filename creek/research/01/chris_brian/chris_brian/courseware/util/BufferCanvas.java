/* *  * @(#)BufferCanvas.java 0.1 97/08/11 * * Copyright (c) 1997 Ginger Booth.  All Rights Reserved. *  * @history: original * @author Ginger Booth * @version 0.1, August 1997 */package courseware.util;/** A double-buffered canvas.  Draw offscreen.*/import java.awt.*;public class BufferCanvas extends Component {    protected Image offscreen;  // draw offscreen to cut the flicker    protected Graphics offg;    // the graphics context of the offscreen image                                // min=preferred size, requested    private Dimension prefSize = new Dimension();                                // am is the current reality    private Dimension amSize   = new Dimension();    public BufferCanvas(int prefsizex, int prefsizey) {        prefSize      = new Dimension(prefsizex, prefsizey);        amSize        = new Dimension(-1, -1);    }        public BufferCanvas(Dimension d) {        prefSize      = new Dimension(d.width, d.height);        amSize        = new Dimension(-1, -1);    }    public BufferCanvas() {this(1,1);}    // force all the graphics to start over    public void reset() {        if (offscreen != null) {            offscreen.flush();            offscreen = null;        }        amSize.width = -1;    }    /** Ensure we have an offscreen image to draw on, and that the scaling     *  matches its dimensions.     */    synchronized public Graphics getOffscreen() {        Dimension s = getSize();        if (s.width < 1) s.width = 1;        if (s.height < 1) s.height = 1;        if ( (s.width  != amSize.width) ||              (s.height != amSize.height)) {            if (offscreen != null) {                offscreen.flush();            }            offscreen     = createImage(s.width, s.height);            if (offscreen != null) {              amSize.width  = s.width;              amSize.height = s.height;              offg          = offscreen.getGraphics();            }        }        return offg;    }    /** Ensure we have a NEW offscreen image to draw on.     */    protected Graphics newOffscreen() {        Dimension s = getSize();        if (offscreen != null)            offscreen.flush();        amSize.width  = s.width;        amSize.height = s.height;        offscreen     = createImage(amSize.width, amSize.height);         offg          = offscreen.getGraphics();        return offg;    }        // put offscreen graphics onscreen    public void update(Graphics g) { paint(g); }    // put offscreen graphics onscreen    public void paint(Graphics g) {        getOffscreen();        if (offscreen != null)           g.drawImage(offscreen, 0, 0, this);    }    // put offscreen graphics onscreen    public void onscreen() {        if (offscreen != null)           getGraphics().drawImage(offscreen, 0, 0, this);    }        synchronized public void setSize(int w, int h)   {        Dimension d = new Dimension(w, h);        this.setSize(d);    }        synchronized public void setSize(Dimension d)   {        prefSize = d;         super.setSize(d);        getOffscreen();    }    synchronized public void setBounds(int x, int y, int width, int height)   {        Dimension d = new Dimension(width, height);        prefSize = d;         super.setBounds(x,y,width,height);        getOffscreen();    }    public Dimension getPreferredSize() { return prefSize; }    public Dimension getMinimumSize()   { return prefSize; }    public Dimension getCurrentSize()   { return amSize; }    /** Release the graphics allocation. */    public void finalize() {        if (offscreen != null)            offscreen.flush();        offscreen = null;        try {            super.finalize();        } catch (Throwable t) {};    }} /* BufferCanvas */