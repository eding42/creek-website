/* * * @(#)ParamList.java 0.2 98/04/23 * * Copyright (c) 1997-1999 Ginger Booth.  All Rights Reserved. * * @history: vfb, revamp 0.2, April 1998 * @history: original * @author Ginger Booth * @version 0.1, September 1997 * @version 1.0+, mar99, pruning binary. */package courseware.util;/** Generic parameter list. */import java.awt.*;import java.util.*;import java.lang.reflect.*;public class ParamList extends Param implements Cloneable {    private boolean recursive = true;    /** val must be a Vector, and each element must be     *  a Param/List.  If you don't want owner to be called back with the     *  list, you need to setRecursive(false) (it defaults to true).     */    /* Because of the Method.apply stuff, our Vector is being stored     * as element 0 of an Object[] array.  There should be no more.     */    /** This is the one used by ParamMgr, so responsible for all usual     *  ParamLists.     */    public ParamList(String label, Vector val, Class oclass,                     Method classMethod, boolean display)    {        super(label, null, oclass, classMethod, display);        if (val == null)            value = new Object[]{ new Vector(5, 5) };        else            value = new Object[]{val};    }    public ParamList(String label)    {        this(label, null, null, null, true);    }    public ParamList()    {        this("", null, null, null, true);    }    /** Make a ParamList by copying (non-recursively) another. */    public Object clone() {        Param p;        ParamList newlist = new ParamList(name, null, ownerClass,                            method, displayable);        newlist.value = new Object[] { ((Vector) value[0]).clone() };        return newlist;    }    public boolean equals(ParamList other) {      boolean answer = true;      answer = answer && (this.getClass() == other.getClass());      if (name != null)        answer = answer && (name.equals(other.name));      if (value == null)        answer = answer && (other.value==null);      else {        answer = answer && (value.length == other.value.length);      }      // that's enuf testing for parameter lists equal      return answer;    }    /** Make a ParamList by copying (recursively) another. */    protected Object cloneRecursive() {        Object p, newp;        ParamList newlist = (ParamList) this.clone();        Vector v = (Vector) ((ParamList) newlist).value[0];        int numElem = v.size();        /* sigh...may not have needed to case out all this, but it works...*/        for (int i=0; i<numElem; i++) {            p = v.elementAt(i);            if (p instanceof ParamList)                newp = ((ParamList) p).cloneRecursive();            else if (p instanceof IndexParam) {                newp = ((IndexParam) p).clone();            } else if (p instanceof ExecParam)                newp = ((ExecParam) p).clone();            else {                newp = ((Param) p).clone();            }            v.setElementAt(newp, i);        }        return newlist;    }    /** If a list is "recursive", that means when it is applied, the     *  ParamList.apply() method goes down into its members one level,     *  calling apply on members of the list rather than apply on the     *  list as a whole.  Thus if a list is nonrecursive, and apply is     *  called on it, the List's owner is called with the List method,     *  and it is allowed to deal with the list's substructure.  Note     *  that ParamList defaults to recursive.     *     *  Note that ParamLists are always recursive when it comes to     *  *creating* popup menus out of them--whole list goes on popup.     *  Recursive only affects how the data is applied on popdown.     */    public void setRecursive(boolean b) { recursive = b; }    public boolean isRecursive() { return recursive; }    /** Add this param/list to ParamList's list of params. */    public void add(Param p) {        if (p == null) return;        Vector list = (Vector) value[0];        if (list == null) {            value = new Object[] {new Vector(5, 5)};            list = (Vector) value[0];        }        list.addElement(p);    }    /** Remove all members of the list. */    public void removeAll() {      value = new Object[] {new Vector(5,5)};    }    /** Replace a param--used by ParamMgr. */    public boolean replace(Param was, Param isNow) {        Param p;        boolean answer = false;        Vector pv = (Vector) value[0];        pv.trimToSize();        int count = pv.size();        for (int i=0; i < count; i++) {            p = (Param) pv.elementAt(i);            if (p.equals(was)) {                pv.setElementAt(isNow, i);                answer = true;            }        }        return answer;    }    /** target must utilize TableLayout.  This is tricky, in that any     *  ParamList can have sublists, and we've only got two dimensions     *  to work with.  So single items go down the popup, a 2nd level     *  list goes across, and a third level list gets turned into an     *  ExecButton that pops another ParamDialog with its contents.     */    public void addToPopup(Container target, int startcolumn) {        int horizcolumn;        TableLayout tl = (TableLayout) target.getLayout();        if (!displayable) {            return;        }        Enumeration e = ((Vector) value[0]).elements();        Param p;        while (e.hasMoreElements()) {            p = (Param) e.nextElement();            if (p instanceof ParamList) {                // a sublist, arrange 'em sideways on popup                Enumeration e2 = ((ParamList) p).elements();                Param p2;                horizcolumn = startcolumn;                int row = tl.getLastRow()+1   ;                String tempname = p.name;                if ( (tempname != null) && !( tempname.equals("") ) ) {                    Label l = new Label(p.name);                    target.add(l, new TableLayoutConstraint(row, horizcolumn));                    tl.setConstraint(l, row, horizcolumn);                    horizcolumn++;                }                while (e2.hasMoreElements()) {                    p2 = (Param) e2.nextElement();                    if (p2 instanceof ParamList) {                        // down here we have no idea whether need extra                        // buttons in this submenu--never told.  So give                        // both and hope for the best.                        ExecButton submenu = new ExecButton(p2.name,                            (ParamList) p2,                            ParamDialog.WITH_BOTH_BUTTONS);                        target.add(submenu, new TableLayoutConstraint(row,horizcolumn));                        tl.setConstraint(submenu, row, horizcolumn);                        horizcolumn++;                    } else {                        p2.addToPopup(target, row, horizcolumn);                        horizcolumn += 2;                    }                }            } else {                // a single item                p.addToPopup(target, startcolumn);            }        }    }    /** What to do when popup pops down. */    public void popDown(Container target) {        Enumeration e = ((Vector) value[0]).elements();        Param p;        int row = -1;        while (e.hasMoreElements()) {            p = (Param) e.nextElement();            if (p.displayable) {                if (p instanceof ParamList) {                    Enumeration e2 = ((ParamList) p).elements();                    Param p2;                    while (e2.hasMoreElements()) {                        p2 = (Param) e2.nextElement();                        if (p2 instanceof ParamList) {                           // not our problem                        } else {                           p2.popDownOne(target);                           row = p2.myRow;                        }                    }                    if (row >= 0)                       p.popDownClear(target, row);                } else {                    p.popDown(target);                }            }        }        apply();    }    public Enumeration elements()    {   return ((Vector) value[0]).elements(); }    public Param getElement(int i)    {   return (Param) ((Vector) value[0]).elementAt(i); }    public void setElement(int i, Param p)    {      ((Vector) value[0]).setElementAt(p, i);    }    public void removeElement(int i)    {   ((Vector) value[0]).removeElementAt(i); }    public int size()    {   return ((Vector) value[0]).size(); }    /** Apply current values to owners--call their methods, for list.     *  List's method, if any, is applied LAST, so is in effect the     *  popup popdown callback. If any list is not recursive, go straight     *  to executing its method, and don't go down on "apply". Note that     *  ParamDialog doesn't pay attention to "recursive".  The items on     *  a recursive list *are* put onto a popup menu, but on applying the     *  new values, the list method is called instead of the submethods.     */    public void apply() {        if (!recursive)            applyThis();        else {            setFromList();        }    }    /** Invoke the method for the list as a whole.  If parameters of     *  method are ParamList, send self.  If no parameters, send nothing.     *  Anything else, can't cope, because my value holds the list in     *  Object[Vector] format instead of method arguments.     */    private void applyThis() {        if ((method != null) && (owner != null)) {            Class[] mparams = method.getParameterTypes();            try {                if (mparams.length == 0)                   method.invoke(owner, new Object[] {});                else                   method.invoke(owner, new Object[] {this} );            } catch (IllegalAccessException e) {                System.err.println("ParamList.applyThis(): " + e + ", on " + this);            } catch (InvocationTargetException e) {                System.err.println("ParamList.applyThis(): target returned " +                e.getTargetException() + ", on " + this);            }        }    }    public void bindAllObjects(Class c, Object o) {        Object 		one;        // check myself first        if (ownerClass == c)          owner = o;        // now for my friends....        Enumeration e = ((Vector) value[0]).elements();        while (e.hasMoreElements()) {            one = e.nextElement();            if (one instanceof ParamList)                ((ParamList) one).bindAllObjects(c, o);            else {                Param p = (Param) one;                if (p.ownerClass == c)                    p.owner=o;            }        }    }    /** New setMethod which takes a string, since which     *  method is nicely contrained for ParamLists to no-arg or     *  ParamList is only arg.     */    public void setMethod(String methodName) throws NoSuchMethodException    {      Method does = null;      Class[] NO_ARGS = new Class[] {};      Class[] PL_ARG  = new Class[] {ParamList.class};      // assume ownerClass has been set, ignore owner      if (ownerClass!=null) {        try {          does = ownerClass.getMethod(methodName, PL_ARG);        } catch (Exception e) {          does = ownerClass.getMethod(methodName, Param.NO_ARGS_SIGNATURE);          // if this second one fails, let it throw the Exception.        }      }      if (does != null)          method = does;    }    /** Applies all substructure and then self.  I.e., all subparams     *  call their set routines, then the list method, if any, is     *  called.   This routine does not check recursive.  In other     *  words, if "apply" finds a list is recursive, it calls this.     */    public void setFromList() {        // apply myself LAST        setFromSubList();        applyThis();    }    /** setFromSubList is a way for the controller to call back this     *  machinery to apply the sublist on a recursive list.  I.e., the     *  list is nonrecursive, so on apply, the owner was called back     *  without the list's substructure being applied.  Now the owner     *  has decided to go ahead and apply the substructure.  The owner     *  can call this routine to do that.     */    public void setFromSubList() {        Object 		o;        Enumeration e = ((Vector) value[0]).elements();        while (e.hasMoreElements()) {            o = e.nextElement();            if (o instanceof ParamList)                ((ParamList) o).apply();            else                ((Param) o).apply();        }    }    /** Using the current ParamList as the root of the search, find first     *  or last Param/List named "tofind".     */    public Param find(String tofind, boolean returnlast)    {        Param       gotOne = null;        Object      any;        Param       anyOne;        ParamList   list;        Enumeration e = ((Vector) value[0]).elements();        while (e.hasMoreElements()) {            any    = e.nextElement();            anyOne = (Param) any;            // check here            if ( (anyOne.name != null) && (anyOne.name.equals(tofind))) {                if (gotOne == null)                    gotOne = anyOne;            }            if ((gotOne != null) && (!returnlast))                return gotOne;            // go down            if (any instanceof ParamList) {                any  = ((ParamList)any).find(tofind, returnlast);                if (any != null) {                    gotOne = (Param) any;                }            }            if ((gotOne != null) && (!returnlast))                return gotOne;        }        return gotOne;    }    /** Using the current ParamList as the root of the search, find first     *  or last Param that's equal to this one. Note that param.equals     *  checks content, not address. Used to find clones who aren't necessarily     *  named. The returnList flag is to return not the found clone, but the     *  ParamList the clone was found on. If what is to be found, is the list     *  started with (root=target), this does NOT find it. (Because of the     *  returnList option of returning parent rather than target.)     */    public Param find(Param tofind, boolean returnlast, boolean returnList)    {        Param       gotOne = null;        Object      any;        Param       anyOne;        ParamList   list = this;        Enumeration e = ((Vector) value[0]).elements();        while (e.hasMoreElements()) {            any    = e.nextElement();            anyOne = (Param) any;            // check here--for ParamList--for some reason need to force it            if ( (anyOne instanceof ParamList) && (tofind instanceof ParamList) ) {              if ( ((ParamList)anyOne).equals( (ParamList) tofind ) ) {                if (gotOne == null) {                  if (returnList)                    gotOne = list;                  else                    gotOne = anyOne;                }              }            }            if ((gotOne != null) && (!returnlast))                return gotOne;            // check here--for Param            if (anyOne.equals(tofind)) {                if (gotOne == null) {                  if (returnList)                    gotOne = list;                  else                    gotOne = anyOne;                }            }            if ((gotOne != null) && (!returnlast))                return gotOne;            // go down            if (any instanceof ParamList) {                any  = ((ParamList) any).find(tofind, returnlast, returnList);                if (any != null) {                  gotOne = (Param) any;                }            }            if ((gotOne != null) && (!returnlast))                return gotOne;        }        return gotOne;    }    /** Dump a list for debug. */    public void debugList() {        list(0);    }    /** Dump a list for debug. */    private void print(int indents) {        for (int i=0; i<indents; i++)            System.err.print("  ");        System.err.println(this);    }    /** Dump a list for debug. */    private void printParam(int indents, Param p) {        for (int i=0; i<indents; i++)            System.err.print("  ");        System.err.println(p.toString());    }    /** Helper. */    private void list(int indents) {        print(indents);        indents += 2;        Param o;        ParamList pl;        if (value == null) {            System.err.println("*** null list ***");        } else {            Vector v = (Vector) value[0];            Enumeration e = v.elements();            while (e.hasMoreElements()) {                o = (Param) e.nextElement();                if (o instanceof ParamList) {                    pl = (ParamList) o;                    pl.list(indents);                } else {                    printParam(indents, o);                }            }        }        indents--;    }    public String toString()    {        return "ParamList[name=" + name +            ",owner=" + owner +            ",method=" + method +            ",recursive=" + recursive +            ",displayable=" + displayable +            ",value=<Vector>]";    }}