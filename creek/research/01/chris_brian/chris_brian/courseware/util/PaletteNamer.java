/* * * @(#)PaletteNamer.java 0.2 990325 * * Copyright (c) 1997-1999 Ginger Booth.  All Rights Reserved. * * @history: 980504, vfb, revamp, note default palette is now empty, * @history               and colors no longer contain data fields. * @history: original * @author Ginger Booth * @version 0.1, August 1997 * @version 1.0+, March99, split off from Palette */package courseware.util;/** Based on hsb values, generate some English names for either a *  Color or a Palette. */import java.awt.*;import java.util.*;import java.lang.reflect.*;public class PaletteNamer {    // rainbow hues    public static final String RED     = "red";    public static final String PINK    = "pink";    public static final String ORANGE  = "orange";    public static final String YELLOW  = "yellow";    public static final String GREEN   = "green";    public static final String TURQUOISE = "turquoise";    public static final String BLUE    = "blue";    public static final String PURPLE  = "purple";    public static final String MAGENTA = "magenta";    // not rainbow    public static final String GRAY    = "gray";    public static final String WHITE   = "white";    public static final String BLACK   = "black";    public static final String BROWN   = "brown";    // modifiers    public static final String LIGHT    = "light";    public static final String DARK     = "dark";    public static final String BRIGHTS  = "bright";    public static final String WARM     = "warm";    public static final String GREENISH = "greenish";    public static final String HOT      = "hot";    public static final String BLANK    = " ";    public static void addNames(Palette p) {      ColorObj a;      for (int i=0; i < p.getNumColors(); i++) {        a   = (ColorObj) p.getColorObj(i);        a.setName(makeName(a.color));      }      uniquifyNames(p);    }    /** Ensure the names are unique, in context. Digits are added if needed. */    public static void uniquifyNames(Palette p) {      String one;      ColorObj a, b;      int i, j;      int count;      for (i=0; i < p.getNumColors(); i++) {        a   = (ColorObj) p.getColorObj(i);        one = a.name;        count = 1;        for (j = i+1; j < p.getNumColors(); j++) {          b = (ColorObj) p.getColorObj(j);          if (one.equals(b.name)) {            count++;            b.name = one + count;          }        }        if (count > 1)         a.name = one + "1";      }    }    /** Generate some reasonable-ish name string for this color. This is     *  a static routine, callable even if not using a Palette.     */    public static String makeName(Color c) {        // turn the color into hsb, then call that version        float[] hsb = new float[3];        hsb = Color.RGBtoHSB(c.getRed(), c.getGreen(), c.getBlue(), hsb);        return makeName(hsb[0], hsb[1], hsb[2]);    }    /** Generate some reasonable-ish name string for this color. This is     *  a static routine, callable even if not using a Palette, although     *  it's most competent at naming colors Palette creates.   Some day     *  I might bother to reverse-code this.  Not today.     */    public static String makeName(float hue, float sat, float bright)        // refer to p 40, Mathematica, 2nd edition, Stephen Wolfram for        // a diagram which helps the following make sense.    {        StringBuffer scratch = new StringBuffer(50);        // first syphon off the non-rainbow-colors        // low saturation == no color to speak of        if (sat < .1) {            if (bright > 0.95) {                scratch.insert(0, WHITE);                return scratch.toString();            } else if (bright < 0.1) {                scratch.insert(0, BLACK);                return scratch.toString();            }            scratch.insert(0, GRAY);            if (bright < 0.3)                scratch.insert(0, DARK + BLANK);            else if (bright > 0.6)                scratch.insert(0, LIGHT + BLANK);            return scratch.toString();        }        // browns        if ( (hue >= 0.1) && (hue <= 0.3) && (bright < 0.6)) {            scratch.append(BROWN);            if (hue < 0.14)                scratch.insert(0, WARM + BLANK);            else if (hue > 0.2)                scratch.insert(0, GREENISH + BLANK);            if (bright >= 0.5)                scratch.insert(0, LIGHT + BLANK);            else if (bright <= 0.35)                scratch.insert(0, DARK + BLANK);            return scratch.toString();        }        if ((hue <= 0.05) || (hue > 0.94)) {            if (sat <= 0.5)                scratch.append(PINK);            else scratch.append(RED);        }        else if (hue <= 0.08)            scratch.append(RED + BLANK + ORANGE);        else if (hue <= 0.1)            scratch.append(ORANGE);        else if (hue <= 0.14)            scratch.append(YELLOW + BLANK + ORANGE);        else if (hue <= 0.18)            scratch.append(YELLOW);        else if (hue <= 0.25)            scratch.append(YELLOW + BLANK + GREEN);        else if (hue <= 0.4)            scratch.append(GREEN);        else if (hue <= Palette.turqbegin)            scratch.append(BLUE + BLANK + GREEN);        else if (hue <= 0.6)            scratch.append(TURQUOISE);        else if (hue <= 0.73)            scratch.append(BLUE);        else if (hue <= 0.81)            scratch.append(PURPLE);        else if (hue <= 0.94) {            if ((sat < 0.8) && (bright > 0.6))                scratch.append(HOT + BLANK + PINK);            else                scratch.append(MAGENTA);        }        return scratch.toString();    }} /* PaletteNamer */